#include "ir.h"
namespace nb = nanobind;
using namespace nb::literals;

void populateArithModule(nanobind::module_ & m) {
using namespace mlir;
using namespace mlir::detail;
using namespace mlir::arith;
auto mlir_arith_ArithDialect = nb::class_<mlir::arith::ArithDialect, mlir::Dialect>(m, "ArithDialect")
.def_static("dialect_namespace", &mlir::arith::ArithDialect::getDialectNamespace)
.def("parse_attribute", &mlir::arith::ArithDialect::parseAttribute, "parser"_a, "type"_a)
.def("print_attribute", &mlir::arith::ArithDialect::printAttribute, "attr"_a, "os"_a)
.def("materialize_constant", &mlir::arith::ArithDialect::materializeConstant, "builder"_a, "value"_a, "type"_a, "loc"_a, nb::rv_policy::reference_internal)
.def_static("insert_into_registry", [](mlir::DialectRegistry &registry) { registry.insert<mlir::arith::ArithDialect>(); })
.def_static("load_into_context", [](mlir::MLIRContext &context) { return context.getOrLoadDialect<mlir::arith::ArithDialect>(); })
;

auto mlir_detail_TypeIDResolver___mlir_arith_ArithDialect__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::ArithDialect>>(m, "TypeIDResolver[arith::ArithDialect]")
;

nb::enum_<mlir::arith::CmpFPredicate>(m, "CmpFPredicate")
.value("AlwaysFalse", mlir::arith::CmpFPredicate::AlwaysFalse)
.value("OEQ", mlir::arith::CmpFPredicate::OEQ)
.value("OGT", mlir::arith::CmpFPredicate::OGT)
.value("OGE", mlir::arith::CmpFPredicate::OGE)
.value("OLT", mlir::arith::CmpFPredicate::OLT)
.value("OLE", mlir::arith::CmpFPredicate::OLE)
.value("ONE", mlir::arith::CmpFPredicate::ONE)
.value("ORD", mlir::arith::CmpFPredicate::ORD)
.value("UEQ", mlir::arith::CmpFPredicate::UEQ)
.value("UGT", mlir::arith::CmpFPredicate::UGT)
.value("UGE", mlir::arith::CmpFPredicate::UGE)
.value("ULT", mlir::arith::CmpFPredicate::ULT)
.value("ULE", mlir::arith::CmpFPredicate::ULE)
.value("UNE", mlir::arith::CmpFPredicate::UNE)
.value("UNO", mlir::arith::CmpFPredicate::UNO)
.value("AlwaysTrue", mlir::arith::CmpFPredicate::AlwaysTrue)
;

auto mlir_arith_CmpFPredicateAttr = nb::class_<mlir::arith::CmpFPredicateAttr, mlir::IntegerAttr>(m, "CmpFPredicateAttr")
.def_static("classof", &mlir::arith::CmpFPredicateAttr::classof, "attr"_a)
.def_static("get", &mlir::arith::CmpFPredicateAttr::get, "context"_a, "val"_a)
.def_prop_ro("value", &mlir::arith::CmpFPredicateAttr::getValue)
;

auto mlir_FieldParser___mlir_arith_CmpFPredicate_____mlir_arith_CmpFPredicate__ = nb::class_<mlir::FieldParser<::mlir::arith::CmpFPredicate,::mlir::arith::CmpFPredicate>>(m, "FieldParser[arith::CmpFPredicate,arith::CmpFPredicate]")
;

nb::enum_<mlir::arith::CmpIPredicate>(m, "CmpIPredicate")
.value("eq", mlir::arith::CmpIPredicate::eq)
.value("ne", mlir::arith::CmpIPredicate::ne)
.value("slt", mlir::arith::CmpIPredicate::slt)
.value("sle", mlir::arith::CmpIPredicate::sle)
.value("sgt", mlir::arith::CmpIPredicate::sgt)
.value("sge", mlir::arith::CmpIPredicate::sge)
.value("ult", mlir::arith::CmpIPredicate::ult)
.value("ule", mlir::arith::CmpIPredicate::ule)
.value("ugt", mlir::arith::CmpIPredicate::ugt)
.value("uge", mlir::arith::CmpIPredicate::uge)
;

auto mlir_arith_CmpIPredicateAttr = nb::class_<mlir::arith::CmpIPredicateAttr, mlir::IntegerAttr>(m, "CmpIPredicateAttr")
.def_static("classof", &mlir::arith::CmpIPredicateAttr::classof, "attr"_a)
.def_static("get", &mlir::arith::CmpIPredicateAttr::get, "context"_a, "val"_a)
.def_prop_ro("value", &mlir::arith::CmpIPredicateAttr::getValue)
;

auto mlir_FieldParser___mlir_arith_CmpIPredicate_____mlir_arith_CmpIPredicate__ = nb::class_<mlir::FieldParser<::mlir::arith::CmpIPredicate,::mlir::arith::CmpIPredicate>>(m, "FieldParser[arith::CmpIPredicate,arith::CmpIPredicate]")
;

nb::enum_<mlir::arith::DenormalMode>(m, "DenormalMode")
.value("ieee", mlir::arith::DenormalMode::ieee)
.value("preserve_sign", mlir::arith::DenormalMode::preserve_sign)
.value("positive_zero", mlir::arith::DenormalMode::positive_zero)
;

auto mlir_FieldParser___mlir_arith_DenormalMode_____mlir_arith_DenormalMode__ = nb::class_<mlir::FieldParser<::mlir::arith::DenormalMode,::mlir::arith::DenormalMode>>(m, "FieldParser[arith::DenormalMode,arith::DenormalMode]")
;

nb::enum_<mlir::arith::IntegerOverflowFlags>(m, "IntegerOverflowFlags")
.value("none", mlir::arith::IntegerOverflowFlags::none)
.value("nsw", mlir::arith::IntegerOverflowFlags::nsw)
.value("nuw", mlir::arith::IntegerOverflowFlags::nuw)
;

auto mlir_FieldParser___mlir_arith_IntegerOverflowFlags_____mlir_arith_IntegerOverflowFlags__ = nb::class_<mlir::FieldParser<::mlir::arith::IntegerOverflowFlags,::mlir::arith::IntegerOverflowFlags>>(m, "FieldParser[arith::IntegerOverflowFlags,arith::IntegerOverflowFlags]")
;

nb::enum_<mlir::arith::RoundingMode>(m, "RoundingMode")
.value("to_nearest_even", mlir::arith::RoundingMode::to_nearest_even)
.value("downward", mlir::arith::RoundingMode::downward)
.value("upward", mlir::arith::RoundingMode::upward)
.value("toward_zero", mlir::arith::RoundingMode::toward_zero)
.value("to_nearest_away", mlir::arith::RoundingMode::to_nearest_away)
;

auto mlir_arith_RoundingModeAttr = nb::class_<mlir::arith::RoundingModeAttr, mlir::IntegerAttr>(m, "RoundingModeAttr")
.def_static("classof", &mlir::arith::RoundingModeAttr::classof, "attr"_a)
.def_static("get", &mlir::arith::RoundingModeAttr::get, "context"_a, "val"_a)
.def_prop_ro("value", &mlir::arith::RoundingModeAttr::getValue)
;

auto mlir_FieldParser___mlir_arith_RoundingMode_____mlir_arith_RoundingMode__ = nb::class_<mlir::FieldParser<::mlir::arith::RoundingMode,::mlir::arith::RoundingMode>>(m, "FieldParser[arith::RoundingMode,arith::RoundingMode]")
;

nb::enum_<mlir::arith::AtomicRMWKind>(m, "AtomicRMWKind")
.value("addf", mlir::arith::AtomicRMWKind::addf)
.value("addi", mlir::arith::AtomicRMWKind::addi)
.value("assign", mlir::arith::AtomicRMWKind::assign)
.value("maximumf", mlir::arith::AtomicRMWKind::maximumf)
.value("maxs", mlir::arith::AtomicRMWKind::maxs)
.value("maxu", mlir::arith::AtomicRMWKind::maxu)
.value("minimumf", mlir::arith::AtomicRMWKind::minimumf)
.value("mins", mlir::arith::AtomicRMWKind::mins)
.value("minu", mlir::arith::AtomicRMWKind::minu)
.value("mulf", mlir::arith::AtomicRMWKind::mulf)
.value("muli", mlir::arith::AtomicRMWKind::muli)
.value("ori", mlir::arith::AtomicRMWKind::ori)
.value("andi", mlir::arith::AtomicRMWKind::andi)
.value("maxnumf", mlir::arith::AtomicRMWKind::maxnumf)
.value("minnumf", mlir::arith::AtomicRMWKind::minnumf)
;

auto mlir_arith_AtomicRMWKindAttr = nb::class_<mlir::arith::AtomicRMWKindAttr, mlir::IntegerAttr>(m, "AtomicRMWKindAttr")
.def_static("classof", &mlir::arith::AtomicRMWKindAttr::classof, "attr"_a)
.def_static("get", &mlir::arith::AtomicRMWKindAttr::get, "context"_a, "val"_a)
.def_prop_ro("value", &mlir::arith::AtomicRMWKindAttr::getValue)
;

auto mlir_FieldParser___mlir_arith_AtomicRMWKind_____mlir_arith_AtomicRMWKind__ = nb::class_<mlir::FieldParser<::mlir::arith::AtomicRMWKind,::mlir::arith::AtomicRMWKind>>(m, "FieldParser[arith::AtomicRMWKind,arith::AtomicRMWKind]")
;

nb::enum_<mlir::arith::FastMathFlags>(m, "FastMathFlags")
.value("none", mlir::arith::FastMathFlags::none)
.value("reassoc", mlir::arith::FastMathFlags::reassoc)
.value("nnan", mlir::arith::FastMathFlags::nnan)
.value("ninf", mlir::arith::FastMathFlags::ninf)
.value("nsz", mlir::arith::FastMathFlags::nsz)
.value("arcp", mlir::arith::FastMathFlags::arcp)
.value("contract", mlir::arith::FastMathFlags::contract)
.value("afn", mlir::arith::FastMathFlags::afn)
.value("fast", mlir::arith::FastMathFlags::fast)
;

auto mlir_FieldParser___mlir_arith_FastMathFlags_____mlir_arith_FastMathFlags__ = nb::class_<mlir::FieldParser<::mlir::arith::FastMathFlags,::mlir::arith::FastMathFlags>>(m, "FieldParser[arith::FastMathFlags,arith::FastMathFlags]")
;

auto mlir_arith_FastMathFlagsAttr = nb::class_<mlir::arith::FastMathFlagsAttr, mlir::Attribute>(m, "FastMathFlagsAttr")
.def_static("get", &mlir::arith::FastMathFlagsAttr::get, "context"_a, "value"_a)
.def_static("mnemonic", &mlir::arith::FastMathFlagsAttr::getMnemonic)
.def_static("parse", &mlir::arith::FastMathFlagsAttr::parse, "ods_parser"_a, "ods_type"_a)
.def("print", &mlir::arith::FastMathFlagsAttr::print, "ods_printer"_a)
.def_prop_ro("value", &mlir::arith::FastMathFlagsAttr::getValue)
;

auto mlir_arith_IntegerOverflowFlagsAttr = nb::class_<mlir::arith::IntegerOverflowFlagsAttr, mlir::Attribute>(m, "IntegerOverflowFlagsAttr")
.def_static("get", &mlir::arith::IntegerOverflowFlagsAttr::get, "context"_a, "value"_a)
.def_static("mnemonic", &mlir::arith::IntegerOverflowFlagsAttr::getMnemonic)
.def_static("parse", &mlir::arith::IntegerOverflowFlagsAttr::parse, "ods_parser"_a, "ods_type"_a)
.def("print", &mlir::arith::IntegerOverflowFlagsAttr::print, "ods_printer"_a)
.def_prop_ro("value", &mlir::arith::IntegerOverflowFlagsAttr::getValue)
;

auto mlir_arith_DenormalModeAttr = nb::class_<mlir::arith::DenormalModeAttr, mlir::Attribute>(m, "DenormalModeAttr")
.def_static("get", &mlir::arith::DenormalModeAttr::get, "context"_a, "value"_a)
.def_static("mnemonic", &mlir::arith::DenormalModeAttr::getMnemonic)
.def_static("parse", &mlir::arith::DenormalModeAttr::parse, "ods_parser"_a, "ods_type"_a)
.def("print", &mlir::arith::DenormalModeAttr::print, "ods_printer"_a)
.def_prop_ro("value", &mlir::arith::DenormalModeAttr::getValue)
;

auto mlir_detail_TypeIDResolver___mlir_arith_FastMathFlagsAttr__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::FastMathFlagsAttr>>(m, "TypeIDResolver[arith::FastMathFlagsAttr]")
;

auto mlir_detail_TypeIDResolver___mlir_arith_IntegerOverflowFlagsAttr__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::IntegerOverflowFlagsAttr>>(m, "TypeIDResolver[arith::IntegerOverflowFlagsAttr]")
;

auto mlir_detail_TypeIDResolver___mlir_arith_DenormalModeAttr__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::DenormalModeAttr>>(m, "TypeIDResolver[arith::DenormalModeAttr]")
;

auto mlir_arith_detail_ArithFastMathInterfaceInterfaceTraits = nb::class_<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits>(m, "ArithFastMathInterfaceInterfaceTraits")
;

auto mlir_arith_detail_ArithFastMathInterfaceInterfaceTraits_Concept = nb::class_<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Concept>(mlir_arith_detail_ArithFastMathInterfaceInterfaceTraits, "Concept")
;

auto mlir_arith_ArithFastMathInterface = nb::class_<mlir::arith::ArithFastMathInterface>(m, "ArithFastMathInterface")
.def_prop_ro("fast_math_flags_attr", &mlir::arith::ArithFastMathInterface::getFastMathFlagsAttr)
.def_prop_ro("fast_math_attr_name", &mlir::arith::ArithFastMathInterface::getFastMathAttrName)
;

auto mlir_arith_detail_ArithIntegerOverflowFlagsInterfaceInterfaceTraits = nb::class_<mlir::arith::detail::ArithIntegerOverflowFlagsInterfaceInterfaceTraits>(m, "ArithIntegerOverflowFlagsInterfaceInterfaceTraits")
;

auto mlir_arith_detail_ArithIntegerOverflowFlagsInterfaceInterfaceTraits_Concept = nb::class_<mlir::arith::detail::ArithIntegerOverflowFlagsInterfaceInterfaceTraits::Concept>(mlir_arith_detail_ArithIntegerOverflowFlagsInterfaceInterfaceTraits, "Concept")
;

auto mlir_arith_ArithIntegerOverflowFlagsInterface = nb::class_<mlir::arith::ArithIntegerOverflowFlagsInterface>(m, "ArithIntegerOverflowFlagsInterface")
.def_prop_ro("overflow_attr", &mlir::arith::ArithIntegerOverflowFlagsInterface::getOverflowAttr)
.def("has_no_unsigned_wrap", &mlir::arith::ArithIntegerOverflowFlagsInterface::hasNoUnsignedWrap)
.def("has_no_signed_wrap", &mlir::arith::ArithIntegerOverflowFlagsInterface::hasNoSignedWrap)
.def_prop_ro("integer_overflow_attr_name", &mlir::arith::ArithIntegerOverflowFlagsInterface::getIntegerOverflowAttrName)
;

auto mlir_arith_detail_ArithRoundingModeInterfaceInterfaceTraits = nb::class_<mlir::arith::detail::ArithRoundingModeInterfaceInterfaceTraits>(m, "ArithRoundingModeInterfaceInterfaceTraits")
;

auto mlir_arith_detail_ArithRoundingModeInterfaceInterfaceTraits_Concept = nb::class_<mlir::arith::detail::ArithRoundingModeInterfaceInterfaceTraits::Concept>(mlir_arith_detail_ArithRoundingModeInterfaceInterfaceTraits, "Concept")
;

auto mlir_arith_ArithRoundingModeInterface = nb::class_<mlir::arith::ArithRoundingModeInterface>(m, "ArithRoundingModeInterface")
.def_prop_ro("rounding_mode_attr", &mlir::arith::ArithRoundingModeInterface::getRoundingModeAttr)
.def_prop_ro("rounding_mode_attr_name", &mlir::arith::ArithRoundingModeInterface::getRoundingModeAttrName)
;

auto mlir_arith_detail_ArithDenormalModeInterfaceInterfaceTraits = nb::class_<mlir::arith::detail::ArithDenormalModeInterfaceInterfaceTraits>(m, "ArithDenormalModeInterfaceInterfaceTraits")
;

auto mlir_arith_detail_ArithDenormalModeInterfaceInterfaceTraits_Concept = nb::class_<mlir::arith::detail::ArithDenormalModeInterfaceInterfaceTraits::Concept>(mlir_arith_detail_ArithDenormalModeInterfaceInterfaceTraits, "Concept")
;

auto mlir_arith_ArithDenormalModeInterface = nb::class_<mlir::arith::ArithDenormalModeInterface>(m, "ArithDenormalModeInterface")
.def_prop_ro("denormal_mode_attr", &mlir::arith::ArithDenormalModeInterface::getDenormalModeAttr)
.def_prop_ro("denormal_mode_attr_name", &mlir::arith::ArithDenormalModeInterface::getDenormalModeAttrName)
;

auto mlir_arith_detail_AddFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::AddFOpGenericAdaptorBase>(m, "AddFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::AddFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::AddFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::AddFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::AddFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::AddFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::AddFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::AddFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::AddFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::AddFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_AddFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::AddFOpGenericAdaptorBase::Properties>(mlir_arith_detail_AddFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::AddFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::AddFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::AddFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::AddFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::AddFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::AddFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_AddFOpAdaptor = nb::class_<mlir::arith::AddFOpAdaptor>(m, "AddFOpAdaptor")
.def(nb::init<mlir::arith::AddFOp>(), "op"_a)
.def("verify", &mlir::arith::AddFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_AddFOp = nb::class_<mlir::arith::AddFOp,  mlir::OpState>(m, "AddFOp")
.def_static("attribute_names", &mlir::arith::AddFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::AddFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::AddFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::AddFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::AddFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::AddFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::AddFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::AddFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::AddFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::AddFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::AddFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::AddFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::AddFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::AddFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::AddFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::AddFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::AddFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::AddFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::AddFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::AddFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::AddFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::AddFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::AddFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::AddFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::AddFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::AddFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::AddFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::AddFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::AddFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::AddFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::AddFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::AddFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::AddFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::AddFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::AddFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::AddFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::AddFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::AddFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::AddFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::AddFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::AddFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::AddFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::AddFOp::verifyInvariants)
.def("fold", &mlir::arith::AddFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::AddFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::AddFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::AddFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_AddFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::AddFOp>>(m, "TypeIDResolver[arith::AddFOp]")
;

auto mlir_arith_detail_AddIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::AddIOpGenericAdaptorBase>(m, "AddIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::AddIOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::AddIOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::AddIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::AddIOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::AddIOpGenericAdaptorBase::getAttributes)
.def_prop_ro("overflow_flags_attr", &mlir::arith::detail::AddIOpGenericAdaptorBase::getOverflowFlagsAttr)
.def_prop_ro("overflow_flags", &mlir::arith::detail::AddIOpGenericAdaptorBase::getOverflowFlags)
;

auto mlir_arith_detail_AddIOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::AddIOpGenericAdaptorBase::Properties>(mlir_arith_detail_AddIOpGenericAdaptorBase, "Properties")
.def_prop_ro("overflow_flags", &mlir::arith::detail::AddIOpGenericAdaptorBase::Properties::getOverflowFlags)
.def("set_overflow_flags", &mlir::arith::detail::AddIOpGenericAdaptorBase::Properties::setOverflowFlags, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::AddIOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::AddIOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_AddIOpAdaptor = nb::class_<mlir::arith::AddIOpAdaptor>(m, "AddIOpAdaptor")
.def(nb::init<mlir::arith::AddIOp>(), "op"_a)
.def("verify", &mlir::arith::AddIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_AddIOp = nb::class_<mlir::arith::AddIOp,  mlir::OpState>(m, "AddIOp")
.def_static("attribute_names", &mlir::arith::AddIOp::getAttributeNames)
.def_prop_ro("overflow_flags_attr_name", [](mlir::arith::AddIOp& self){ return self.getOverflowFlagsAttrName(); })
.def_static("get_overflow_flags_attr_name", [](mlir::OperationName name){ return mlir::arith::AddIOp::getOverflowFlagsAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::AddIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::AddIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::AddIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::AddIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::AddIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::AddIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::AddIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::AddIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::AddIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::AddIOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::AddIOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::AddIOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::AddIOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::AddIOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::AddIOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::AddIOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::AddIOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::AddIOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::AddIOp::writeProperties, "writer"_a)
.def_prop_ro("overflow_flags_attr", &mlir::arith::AddIOp::getOverflowFlagsAttr)
.def_prop_ro("overflow_flags", &mlir::arith::AddIOp::getOverflowFlags)
.def("set_overflow_flags_attr", &mlir::arith::AddIOp::setOverflowFlagsAttr, "attr"_a)
.def("set_overflow_flags", &mlir::arith::AddIOp::setOverflowFlags, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::AddIOp::build(odsBuilder, odsState, result, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::AddIOp::build(odsBuilder, odsState, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::AddIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::AddIOp::build(odsBuilder, odsState, result, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::AddIOp::build(odsBuilder, odsState, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::AddIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::AddIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::AddIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::AddIOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::AddIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::AddIOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::AddIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::AddIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::AddIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::AddIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::AddIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::AddIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_AddIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::AddIOp>>(m, "TypeIDResolver[arith::AddIOp]")
;

auto mlir_arith_detail_AddUIExtendedOpGenericAdaptorBase = nb::class_<mlir::arith::detail::AddUIExtendedOpGenericAdaptorBase>(m, "AddUIExtendedOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::AddUIExtendedOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::AddUIExtendedOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_AddUIExtendedOpAdaptor = nb::class_<mlir::arith::AddUIExtendedOpAdaptor>(m, "AddUIExtendedOpAdaptor")
.def(nb::init<mlir::arith::AddUIExtendedOp>(), "op"_a)
.def("verify", &mlir::arith::AddUIExtendedOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_AddUIExtendedOp = nb::class_<mlir::arith::AddUIExtendedOp,  mlir::OpState>(m, "AddUIExtendedOp")
.def_static("attribute_names", &mlir::arith::AddUIExtendedOp::getAttributeNames)
.def("get_asm_result_names", &mlir::arith::AddUIExtendedOp::getAsmResultNames, "set_name_fn"_a)
.def_static("operation_name", &mlir::arith::AddUIExtendedOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::AddUIExtendedOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::AddUIExtendedOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::AddUIExtendedOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::AddUIExtendedOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::AddUIExtendedOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::AddUIExtendedOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::AddUIExtendedOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::AddUIExtendedOp::getODSResults, "index"_a)
.def_prop_ro("sum", &mlir::arith::AddUIExtendedOp::getSum)
.def_prop_ro("overflow", &mlir::arith::AddUIExtendedOp::getOverflow)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::AddUIExtendedOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type sum, mlir::Type overflow, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::AddUIExtendedOp::build(odsBuilder, odsState, sum, overflow, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "sum"_a, "overflow"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::AddUIExtendedOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::AddUIExtendedOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::AddUIExtendedOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::AddUIExtendedOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::AddUIExtendedOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::AddUIExtendedOp::fold, "adaptor"_a, "results"_a)
.def_static("parse", &mlir::arith::AddUIExtendedOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::AddUIExtendedOp::getEffects, "effects"_a)
.def_prop_ro("shape_for_unroll", &mlir::arith::AddUIExtendedOp::getShapeForUnroll)
;

auto mlir_detail_TypeIDResolver___mlir_arith_AddUIExtendedOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::AddUIExtendedOp>>(m, "TypeIDResolver[arith::AddUIExtendedOp]")
;

auto mlir_arith_detail_AndIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::AndIOpGenericAdaptorBase>(m, "AndIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::AndIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::AndIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_AndIOpAdaptor = nb::class_<mlir::arith::AndIOpAdaptor>(m, "AndIOpAdaptor")
.def(nb::init<mlir::arith::AndIOp>(), "op"_a)
.def("verify", &mlir::arith::AndIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_AndIOp = nb::class_<mlir::arith::AndIOp,  mlir::OpState>(m, "AndIOp")
.def_static("attribute_names", &mlir::arith::AndIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::AndIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::AndIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::AndIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::AndIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::AndIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::AndIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::AndIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::AndIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::AndIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::AndIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::AndIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::AndIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::AndIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::AndIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::AndIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::AndIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::AndIOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::AndIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::AndIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::AndIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::AndIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::AndIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::AndIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_AndIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::AndIOp>>(m, "TypeIDResolver[arith::AndIOp]")
;

auto mlir_arith_detail_BitcastOpGenericAdaptorBase = nb::class_<mlir::arith::detail::BitcastOpGenericAdaptorBase>(m, "BitcastOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::BitcastOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::BitcastOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_BitcastOpAdaptor = nb::class_<mlir::arith::BitcastOpAdaptor>(m, "BitcastOpAdaptor")
.def(nb::init<mlir::arith::BitcastOp>(), "op"_a)
.def("verify", &mlir::arith::BitcastOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_BitcastOp = nb::class_<mlir::arith::BitcastOp,  mlir::OpState>(m, "BitcastOp")
.def_static("attribute_names", &mlir::arith::BitcastOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::BitcastOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::BitcastOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::BitcastOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::BitcastOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::BitcastOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::BitcastOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::BitcastOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::BitcastOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::BitcastOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::BitcastOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::BitcastOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::BitcastOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::BitcastOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::BitcastOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::BitcastOp::fold, "adaptor"_a)
.def_static("are_cast_compatible", &mlir::arith::BitcastOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::BitcastOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::BitcastOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_BitcastOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::BitcastOp>>(m, "TypeIDResolver[arith::BitcastOp]")
;

auto mlir_arith_detail_CeilDivSIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::CeilDivSIOpGenericAdaptorBase>(m, "CeilDivSIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::CeilDivSIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::CeilDivSIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_CeilDivSIOpAdaptor = nb::class_<mlir::arith::CeilDivSIOpAdaptor>(m, "CeilDivSIOpAdaptor")
.def(nb::init<mlir::arith::CeilDivSIOp>(), "op"_a)
.def("verify", &mlir::arith::CeilDivSIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_CeilDivSIOp = nb::class_<mlir::arith::CeilDivSIOp,  mlir::OpState>(m, "CeilDivSIOp")
.def_static("attribute_names", &mlir::arith::CeilDivSIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::CeilDivSIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::CeilDivSIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::CeilDivSIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::CeilDivSIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::CeilDivSIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::CeilDivSIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::CeilDivSIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::CeilDivSIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::CeilDivSIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::CeilDivSIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CeilDivSIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CeilDivSIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CeilDivSIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::CeilDivSIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::CeilDivSIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::CeilDivSIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::CeilDivSIOp::verifyInvariants)
.def("fold", &mlir::arith::CeilDivSIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::CeilDivSIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::CeilDivSIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::CeilDivSIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::CeilDivSIOp::getEffects, "effects"_a)
.def_prop_ro("speculatability", &mlir::arith::CeilDivSIOp::getSpeculatability)
;

auto mlir_detail_TypeIDResolver___mlir_arith_CeilDivSIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::CeilDivSIOp>>(m, "TypeIDResolver[arith::CeilDivSIOp]")
;

auto mlir_arith_detail_CeilDivUIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::CeilDivUIOpGenericAdaptorBase>(m, "CeilDivUIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::CeilDivUIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::CeilDivUIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_CeilDivUIOpAdaptor = nb::class_<mlir::arith::CeilDivUIOpAdaptor>(m, "CeilDivUIOpAdaptor")
.def(nb::init<mlir::arith::CeilDivUIOp>(), "op"_a)
.def("verify", &mlir::arith::CeilDivUIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_CeilDivUIOp = nb::class_<mlir::arith::CeilDivUIOp,  mlir::OpState>(m, "CeilDivUIOp")
.def_static("attribute_names", &mlir::arith::CeilDivUIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::CeilDivUIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::CeilDivUIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::CeilDivUIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::CeilDivUIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::CeilDivUIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::CeilDivUIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::CeilDivUIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::CeilDivUIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::CeilDivUIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::CeilDivUIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CeilDivUIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CeilDivUIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CeilDivUIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::CeilDivUIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::CeilDivUIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::CeilDivUIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::CeilDivUIOp::verifyInvariants)
.def("fold", &mlir::arith::CeilDivUIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::CeilDivUIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::CeilDivUIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::CeilDivUIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::CeilDivUIOp::getEffects, "effects"_a)
.def_prop_ro("speculatability", &mlir::arith::CeilDivUIOp::getSpeculatability)
;

auto mlir_detail_TypeIDResolver___mlir_arith_CeilDivUIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::CeilDivUIOp>>(m, "TypeIDResolver[arith::CeilDivUIOp]")
;

auto mlir_arith_detail_CmpFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::CmpFOpGenericAdaptorBase>(m, "CmpFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::CmpFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::CmpFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::CmpFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::CmpFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::CmpFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("predicate_attr", &mlir::arith::detail::CmpFOpGenericAdaptorBase::getPredicateAttr)
.def_prop_ro("predicate", &mlir::arith::detail::CmpFOpGenericAdaptorBase::getPredicate)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::CmpFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::CmpFOpGenericAdaptorBase::getFastmath)
;

auto mlir_arith_detail_CmpFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::CmpFOpGenericAdaptorBase::Properties>(mlir_arith_detail_CmpFOpGenericAdaptorBase, "Properties")
.def_prop_ro("fastmath", &mlir::arith::detail::CmpFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::CmpFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def_prop_ro("predicate", &mlir::arith::detail::CmpFOpGenericAdaptorBase::Properties::getPredicate)
.def("set_predicate", &mlir::arith::detail::CmpFOpGenericAdaptorBase::Properties::setPredicate, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::CmpFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::CmpFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_CmpFOpAdaptor = nb::class_<mlir::arith::CmpFOpAdaptor>(m, "CmpFOpAdaptor")
.def(nb::init<mlir::arith::CmpFOp>(), "op"_a)
.def("verify", &mlir::arith::CmpFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_CmpFOp = nb::class_<mlir::arith::CmpFOp,  mlir::OpState>(m, "CmpFOp")
.def_static("attribute_names", &mlir::arith::CmpFOp::getAttributeNames)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::CmpFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::CmpFOp::getFastmathAttrName(name); }, "name"_a)
.def_prop_ro("predicate_attr_name", [](mlir::arith::CmpFOp& self){ return self.getPredicateAttrName(); })
.def_static("get_predicate_attr_name", [](mlir::OperationName name){ return mlir::arith::CmpFOp::getPredicateAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::CmpFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::CmpFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::CmpFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::CmpFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::CmpFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::CmpFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::CmpFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::CmpFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::CmpFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::CmpFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::CmpFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::CmpFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::CmpFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::CmpFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::CmpFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::CmpFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::CmpFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::CmpFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::CmpFOp::writeProperties, "writer"_a)
.def_prop_ro("predicate_attr", &mlir::arith::CmpFOp::getPredicateAttr)
.def_prop_ro("predicate", &mlir::arith::CmpFOp::getPredicate)
.def_prop_ro("fastmath_attr", &mlir::arith::CmpFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::CmpFOp::getFastmath)
.def("set_predicate_attr", &mlir::arith::CmpFOp::setPredicateAttr, "attr"_a)
.def("set_predicate", &mlir::arith::CmpFOp::setPredicate, "attr_value"_a)
.def("set_fastmath_attr", &mlir::arith::CmpFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::CmpFOp::setFastmath, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::arith::CmpFPredicateAttr predicate, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CmpFOp::build(odsBuilder, odsState, predicate, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "predicate"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::arith::CmpFPredicateAttr predicate, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath){ return mlir::arith::CmpFOp::build(odsBuilder, odsState, result, predicate, lhs, rhs, fastmath); }, "ods_builder"_a, "ods_state"_a, "result"_a, "predicate"_a, "lhs"_a, "rhs"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::arith::CmpFPredicateAttr predicate, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath){ return mlir::arith::CmpFOp::build(odsBuilder, odsState, predicate, lhs, rhs, fastmath); }, "ods_builder"_a, "ods_state"_a, "predicate"_a, "lhs"_a, "rhs"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::arith::CmpFPredicateAttr predicate, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath){ return mlir::arith::CmpFOp::build(odsBuilder, odsState, resultTypes, predicate, lhs, rhs, fastmath); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "predicate"_a, "lhs"_a, "rhs"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::arith::CmpFPredicate predicate, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath){ return mlir::arith::CmpFOp::build(odsBuilder, odsState, result, predicate, lhs, rhs, fastmath); }, "ods_builder"_a, "ods_state"_a, "result"_a, "predicate"_a, "lhs"_a, "rhs"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::arith::CmpFPredicate predicate, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath){ return mlir::arith::CmpFOp::build(odsBuilder, odsState, predicate, lhs, rhs, fastmath); }, "ods_builder"_a, "ods_state"_a, "predicate"_a, "lhs"_a, "rhs"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::arith::CmpFPredicate predicate, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath){ return mlir::arith::CmpFOp::build(odsBuilder, odsState, resultTypes, predicate, lhs, rhs, fastmath); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "predicate"_a, "lhs"_a, "rhs"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::CmpFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::CmpFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::CmpFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::CmpFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::CmpFOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::CmpFOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::CmpFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::CmpFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::CmpFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::CmpFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_CmpFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::CmpFOp>>(m, "TypeIDResolver[arith::CmpFOp]")
;

auto mlir_arith_detail_CmpIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::CmpIOpGenericAdaptorBase>(m, "CmpIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::CmpIOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::CmpIOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::CmpIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::CmpIOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::CmpIOpGenericAdaptorBase::getAttributes)
.def_prop_ro("predicate_attr", &mlir::arith::detail::CmpIOpGenericAdaptorBase::getPredicateAttr)
.def_prop_ro("predicate", &mlir::arith::detail::CmpIOpGenericAdaptorBase::getPredicate)
;

auto mlir_arith_detail_CmpIOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::CmpIOpGenericAdaptorBase::Properties>(mlir_arith_detail_CmpIOpGenericAdaptorBase, "Properties")
.def_prop_ro("predicate", &mlir::arith::detail::CmpIOpGenericAdaptorBase::Properties::getPredicate)
.def("set_predicate", &mlir::arith::detail::CmpIOpGenericAdaptorBase::Properties::setPredicate, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::CmpIOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::CmpIOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_CmpIOpAdaptor = nb::class_<mlir::arith::CmpIOpAdaptor>(m, "CmpIOpAdaptor")
.def(nb::init<mlir::arith::CmpIOp>(), "op"_a)
.def("verify", &mlir::arith::CmpIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_CmpIOp = nb::class_<mlir::arith::CmpIOp,  mlir::OpState>(m, "CmpIOp")
.def_static("attribute_names", &mlir::arith::CmpIOp::getAttributeNames)
.def_prop_ro("predicate_attr_name", [](mlir::arith::CmpIOp& self){ return self.getPredicateAttrName(); })
.def_static("get_predicate_attr_name", [](mlir::OperationName name){ return mlir::arith::CmpIOp::getPredicateAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::CmpIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::CmpIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::CmpIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::CmpIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::CmpIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::CmpIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::CmpIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::CmpIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::CmpIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::CmpIOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::CmpIOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::CmpIOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::CmpIOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::CmpIOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::CmpIOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::CmpIOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::CmpIOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::CmpIOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::CmpIOp::writeProperties, "writer"_a)
.def_prop_ro("predicate_attr", &mlir::arith::CmpIOp::getPredicateAttr)
.def_prop_ro("predicate", &mlir::arith::CmpIOp::getPredicate)
.def("set_predicate_attr", &mlir::arith::CmpIOp::setPredicateAttr, "attr"_a)
.def("set_predicate", &mlir::arith::CmpIOp::setPredicate, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::arith::CmpIPredicateAttr predicate, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CmpIOp::build(odsBuilder, odsState, result, predicate, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "predicate"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::arith::CmpIPredicateAttr predicate, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CmpIOp::build(odsBuilder, odsState, predicate, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "predicate"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::arith::CmpIPredicateAttr predicate, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CmpIOp::build(odsBuilder, odsState, resultTypes, predicate, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "predicate"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::arith::CmpIPredicate predicate, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CmpIOp::build(odsBuilder, odsState, result, predicate, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "predicate"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::arith::CmpIPredicate predicate, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CmpIOp::build(odsBuilder, odsState, predicate, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "predicate"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::arith::CmpIPredicate predicate, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::CmpIOp::build(odsBuilder, odsState, resultTypes, predicate, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "predicate"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::CmpIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::CmpIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::CmpIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::CmpIOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::CmpIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::CmpIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::CmpIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::CmpIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::CmpIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::CmpIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_CmpIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::CmpIOp>>(m, "TypeIDResolver[arith::CmpIOp]")
;

auto mlir_arith_detail_ConstantOpGenericAdaptorBase = nb::class_<mlir::arith::detail::ConstantOpGenericAdaptorBase>(m, "ConstantOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::ConstantOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::ConstantOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::ConstantOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::ConstantOpGenericAdaptorBase::getAttributes)
.def_prop_ro("value_attr", &mlir::arith::detail::ConstantOpGenericAdaptorBase::getValueAttr)
.def_prop_ro("value", &mlir::arith::detail::ConstantOpGenericAdaptorBase::getValue)
;

auto mlir_arith_detail_ConstantOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties>(mlir_arith_detail_ConstantOpGenericAdaptorBase, "Properties")
.def_prop_ro("value", &mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties::getValue)
.def("set_value", &mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties::setValue, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_ConstantOpAdaptor = nb::class_<mlir::arith::ConstantOpAdaptor>(m, "ConstantOpAdaptor")
.def(nb::init<mlir::arith::ConstantOp>(), "op"_a)
.def("verify", &mlir::arith::ConstantOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_ConstantOp = nb::class_<mlir::arith::ConstantOp,  mlir::OpState>(m, "ConstantOp")
.def_static("attribute_names", &mlir::arith::ConstantOp::getAttributeNames)
.def_prop_ro("value_attr_name", [](mlir::arith::ConstantOp& self){ return self.getValueAttrName(); })
.def_static("get_value_attr_name", [](mlir::OperationName name){ return mlir::arith::ConstantOp::getValueAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::ConstantOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::ConstantOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::ConstantOp::getODSOperands, "index"_a)
.def("get_ods_result_index_and_length", &mlir::arith::ConstantOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::ConstantOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::ConstantOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::ConstantOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::ConstantOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::ConstantOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::ConstantOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::ConstantOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::ConstantOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::ConstantOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::ConstantOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::ConstantOp::writeProperties, "writer"_a)
.def_prop_ro("value_attr", &mlir::arith::ConstantOp::getValueAttr)
.def_prop_ro("value", &mlir::arith::ConstantOp::getValue)
.def("set_value_attr", &mlir::arith::ConstantOp::setValueAttr, "attr"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::TypedAttr value){ return mlir::arith::ConstantOp::build(odsBuilder, odsState, result, value); }, "ods_builder"_a, "ods_state"_a, "result"_a, "value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypedAttr value){ return mlir::arith::ConstantOp::build(odsBuilder, odsState, value); }, "ods_builder"_a, "ods_state"_a, "value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::TypedAttr value){ return mlir::arith::ConstantOp::build(odsBuilder, odsState, resultTypes, value); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "value"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ConstantOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ConstantOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::ConstantOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::ConstantOp::verifyInvariants)
.def("verify", &mlir::arith::ConstantOp::verify)
.def("fold", &mlir::arith::ConstantOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::ConstantOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("get_asm_result_names", &mlir::arith::ConstantOp::getAsmResultNames, "set_name_fn"_a)
.def("infer_result_ranges", &mlir::arith::ConstantOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::ConstantOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::ConstantOp::getEffects, "effects"_a)
.def_static("is_buildable_with", &mlir::arith::ConstantOp::isBuildableWith, "value"_a, "type"_a)
.def_static("materialize", &mlir::arith::ConstantOp::materialize, "builder"_a, "value"_a, "type"_a, "loc"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_ConstantOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::ConstantOp>>(m, "TypeIDResolver[arith::ConstantOp]")
;

auto mlir_arith_detail_DivFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::DivFOpGenericAdaptorBase>(m, "DivFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::DivFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::DivFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::DivFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::DivFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::DivFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::DivFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::DivFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::DivFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::DivFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_DivFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::DivFOpGenericAdaptorBase::Properties>(mlir_arith_detail_DivFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::DivFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::DivFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::DivFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::DivFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::DivFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::DivFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_DivFOpAdaptor = nb::class_<mlir::arith::DivFOpAdaptor>(m, "DivFOpAdaptor")
.def(nb::init<mlir::arith::DivFOp>(), "op"_a)
.def("verify", &mlir::arith::DivFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_DivFOp = nb::class_<mlir::arith::DivFOp,  mlir::OpState>(m, "DivFOp")
.def_static("attribute_names", &mlir::arith::DivFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::DivFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::DivFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::DivFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::DivFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::DivFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::DivFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::DivFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::DivFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::DivFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::DivFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::DivFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::DivFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::DivFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::DivFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::DivFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::DivFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::DivFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::DivFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::DivFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::DivFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::DivFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::DivFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::DivFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::DivFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::DivFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::DivFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::DivFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::DivFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::DivFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::DivFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::DivFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::DivFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::DivFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::DivFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::DivFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::DivFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::DivFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::DivFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::DivFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::DivFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::DivFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::DivFOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::DivFOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::DivFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::DivFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::DivFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::DivFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_DivFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::DivFOp>>(m, "TypeIDResolver[arith::DivFOp]")
;

auto mlir_arith_detail_DivSIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::DivSIOpGenericAdaptorBase>(m, "DivSIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::DivSIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::DivSIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_DivSIOpAdaptor = nb::class_<mlir::arith::DivSIOpAdaptor>(m, "DivSIOpAdaptor")
.def(nb::init<mlir::arith::DivSIOp>(), "op"_a)
.def("verify", &mlir::arith::DivSIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_DivSIOp = nb::class_<mlir::arith::DivSIOp,  mlir::OpState>(m, "DivSIOp")
.def_static("attribute_names", &mlir::arith::DivSIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::DivSIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::DivSIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::DivSIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::DivSIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::DivSIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::DivSIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::DivSIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::DivSIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::DivSIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::DivSIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::DivSIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::DivSIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::DivSIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::DivSIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::DivSIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::DivSIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::DivSIOp::verifyInvariants)
.def("fold", &mlir::arith::DivSIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::DivSIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::DivSIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::DivSIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::DivSIOp::getEffects, "effects"_a)
.def_prop_ro("speculatability", &mlir::arith::DivSIOp::getSpeculatability)
;

auto mlir_detail_TypeIDResolver___mlir_arith_DivSIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::DivSIOp>>(m, "TypeIDResolver[arith::DivSIOp]")
;

auto mlir_arith_detail_DivUIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::DivUIOpGenericAdaptorBase>(m, "DivUIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::DivUIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::DivUIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_DivUIOpAdaptor = nb::class_<mlir::arith::DivUIOpAdaptor>(m, "DivUIOpAdaptor")
.def(nb::init<mlir::arith::DivUIOp>(), "op"_a)
.def("verify", &mlir::arith::DivUIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_DivUIOp = nb::class_<mlir::arith::DivUIOp,  mlir::OpState>(m, "DivUIOp")
.def_static("attribute_names", &mlir::arith::DivUIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::DivUIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::DivUIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::DivUIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::DivUIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::DivUIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::DivUIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::DivUIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::DivUIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::DivUIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::DivUIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::DivUIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::DivUIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::DivUIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::DivUIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::DivUIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::DivUIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::DivUIOp::verifyInvariants)
.def("fold", &mlir::arith::DivUIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::DivUIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::DivUIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::DivUIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::DivUIOp::getEffects, "effects"_a)
.def_prop_ro("speculatability", &mlir::arith::DivUIOp::getSpeculatability)
;

auto mlir_detail_TypeIDResolver___mlir_arith_DivUIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::DivUIOp>>(m, "TypeIDResolver[arith::DivUIOp]")
;

auto mlir_arith_detail_ExtFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::ExtFOpGenericAdaptorBase>(m, "ExtFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::ExtFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::ExtFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::ExtFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::ExtFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::ExtFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::ExtFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::ExtFOpGenericAdaptorBase::getFastmath)
;

auto mlir_arith_detail_ExtFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::ExtFOpGenericAdaptorBase::Properties>(mlir_arith_detail_ExtFOpGenericAdaptorBase, "Properties")
.def_prop_ro("fastmath", &mlir::arith::detail::ExtFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::ExtFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::ExtFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::ExtFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_ExtFOpAdaptor = nb::class_<mlir::arith::ExtFOpAdaptor>(m, "ExtFOpAdaptor")
.def(nb::init<mlir::arith::ExtFOp>(), "op"_a)
.def("verify", &mlir::arith::ExtFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_ExtFOp = nb::class_<mlir::arith::ExtFOp,  mlir::OpState>(m, "ExtFOp")
.def_static("attribute_names", &mlir::arith::ExtFOp::getAttributeNames)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::ExtFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::ExtFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::ExtFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::ExtFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::ExtFOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::ExtFOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::ExtFOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::ExtFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::ExtFOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::ExtFOp::getOut)
.def_static("set_properties_from_attr", &mlir::arith::ExtFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::ExtFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::ExtFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::ExtFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::ExtFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::ExtFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::ExtFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::ExtFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::ExtFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::ExtFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::ExtFOp::getFastmath)
.def("set_fastmath_attr", &mlir::arith::ExtFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::ExtFOp::setFastmath, "attr_value"_a)
.def("remove_fastmath_attr", &mlir::arith::ExtFOp::removeFastmathAttr)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in, mlir::arith::FastMathFlagsAttr fastmath){ return mlir::arith::ExtFOp::build(odsBuilder, odsState, out, in, fastmath); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in, mlir::arith::FastMathFlagsAttr fastmath){ return mlir::arith::ExtFOp::build(odsBuilder, odsState, resultTypes, in, fastmath); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ExtFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::ExtFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::ExtFOp::verifyInvariants)
.def("verify", &mlir::arith::ExtFOp::verify)
.def("fold", &mlir::arith::ExtFOp::fold, "adaptor"_a)
.def_static("are_cast_compatible", &mlir::arith::ExtFOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::ExtFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::ExtFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_ExtFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::ExtFOp>>(m, "TypeIDResolver[arith::ExtFOp]")
;

auto mlir_arith_detail_ExtSIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::ExtSIOpGenericAdaptorBase>(m, "ExtSIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::ExtSIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::ExtSIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_ExtSIOpAdaptor = nb::class_<mlir::arith::ExtSIOpAdaptor>(m, "ExtSIOpAdaptor")
.def(nb::init<mlir::arith::ExtSIOp>(), "op"_a)
.def("verify", &mlir::arith::ExtSIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_ExtSIOp = nb::class_<mlir::arith::ExtSIOp,  mlir::OpState>(m, "ExtSIOp")
.def_static("attribute_names", &mlir::arith::ExtSIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::ExtSIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::ExtSIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::ExtSIOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::ExtSIOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::ExtSIOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::ExtSIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::ExtSIOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::ExtSIOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::ExtSIOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::ExtSIOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ExtSIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::ExtSIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::ExtSIOp::verifyInvariants)
.def("verify", &mlir::arith::ExtSIOp::verify)
.def_static("get_canonicalization_patterns", &mlir::arith::ExtSIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::ExtSIOp::fold, "adaptor"_a)
.def("infer_result_ranges", &mlir::arith::ExtSIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("are_cast_compatible", &mlir::arith::ExtSIOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::ExtSIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::ExtSIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_ExtSIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::ExtSIOp>>(m, "TypeIDResolver[arith::ExtSIOp]")
;

auto mlir_arith_detail_ExtUIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::ExtUIOpGenericAdaptorBase>(m, "ExtUIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::ExtUIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::ExtUIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_ExtUIOpAdaptor = nb::class_<mlir::arith::ExtUIOpAdaptor>(m, "ExtUIOpAdaptor")
.def(nb::init<mlir::arith::ExtUIOp>(), "op"_a)
.def("verify", &mlir::arith::ExtUIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_ExtUIOp = nb::class_<mlir::arith::ExtUIOp,  mlir::OpState>(m, "ExtUIOp")
.def_static("attribute_names", &mlir::arith::ExtUIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::ExtUIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::ExtUIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::ExtUIOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::ExtUIOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::ExtUIOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::ExtUIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::ExtUIOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::ExtUIOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::ExtUIOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::ExtUIOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ExtUIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::ExtUIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::ExtUIOp::verifyInvariants)
.def("verify", &mlir::arith::ExtUIOp::verify)
.def("fold", &mlir::arith::ExtUIOp::fold, "adaptor"_a)
.def("infer_result_ranges", &mlir::arith::ExtUIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("are_cast_compatible", &mlir::arith::ExtUIOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::ExtUIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::ExtUIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_ExtUIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::ExtUIOp>>(m, "TypeIDResolver[arith::ExtUIOp]")
;

auto mlir_arith_detail_FPToSIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::FPToSIOpGenericAdaptorBase>(m, "FPToSIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::FPToSIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::FPToSIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_FPToSIOpAdaptor = nb::class_<mlir::arith::FPToSIOpAdaptor>(m, "FPToSIOpAdaptor")
.def(nb::init<mlir::arith::FPToSIOp>(), "op"_a)
.def("verify", &mlir::arith::FPToSIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_FPToSIOp = nb::class_<mlir::arith::FPToSIOp,  mlir::OpState>(m, "FPToSIOp")
.def_static("attribute_names", &mlir::arith::FPToSIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::FPToSIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::FPToSIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::FPToSIOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::FPToSIOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::FPToSIOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::FPToSIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::FPToSIOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::FPToSIOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::FPToSIOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::FPToSIOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::FPToSIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::FPToSIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::FPToSIOp::verifyInvariants)
.def("fold", &mlir::arith::FPToSIOp::fold, "adaptor"_a)
.def_static("are_cast_compatible", &mlir::arith::FPToSIOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::FPToSIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::FPToSIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_FPToSIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::FPToSIOp>>(m, "TypeIDResolver[arith::FPToSIOp]")
;

auto mlir_arith_detail_FPToUIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::FPToUIOpGenericAdaptorBase>(m, "FPToUIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::FPToUIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::FPToUIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_FPToUIOpAdaptor = nb::class_<mlir::arith::FPToUIOpAdaptor>(m, "FPToUIOpAdaptor")
.def(nb::init<mlir::arith::FPToUIOp>(), "op"_a)
.def("verify", &mlir::arith::FPToUIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_FPToUIOp = nb::class_<mlir::arith::FPToUIOp,  mlir::OpState>(m, "FPToUIOp")
.def_static("attribute_names", &mlir::arith::FPToUIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::FPToUIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::FPToUIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::FPToUIOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::FPToUIOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::FPToUIOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::FPToUIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::FPToUIOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::FPToUIOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::FPToUIOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::FPToUIOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::FPToUIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::FPToUIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::FPToUIOp::verifyInvariants)
.def("fold", &mlir::arith::FPToUIOp::fold, "adaptor"_a)
.def_static("are_cast_compatible", &mlir::arith::FPToUIOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::FPToUIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::FPToUIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_FPToUIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::FPToUIOp>>(m, "TypeIDResolver[arith::FPToUIOp]")
;

auto mlir_arith_detail_FloorDivSIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::FloorDivSIOpGenericAdaptorBase>(m, "FloorDivSIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::FloorDivSIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::FloorDivSIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_FloorDivSIOpAdaptor = nb::class_<mlir::arith::FloorDivSIOpAdaptor>(m, "FloorDivSIOpAdaptor")
.def(nb::init<mlir::arith::FloorDivSIOp>(), "op"_a)
.def("verify", &mlir::arith::FloorDivSIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_FloorDivSIOp = nb::class_<mlir::arith::FloorDivSIOp,  mlir::OpState>(m, "FloorDivSIOp")
.def_static("attribute_names", &mlir::arith::FloorDivSIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::FloorDivSIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::FloorDivSIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::FloorDivSIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::FloorDivSIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::FloorDivSIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::FloorDivSIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::FloorDivSIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::FloorDivSIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::FloorDivSIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::FloorDivSIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::FloorDivSIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::FloorDivSIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::FloorDivSIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::FloorDivSIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::FloorDivSIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::FloorDivSIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::FloorDivSIOp::verifyInvariants)
.def("fold", &mlir::arith::FloorDivSIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::FloorDivSIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::FloorDivSIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::FloorDivSIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::FloorDivSIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_FloorDivSIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::FloorDivSIOp>>(m, "TypeIDResolver[arith::FloorDivSIOp]")
;

auto mlir_arith_detail_IndexCastOpGenericAdaptorBase = nb::class_<mlir::arith::detail::IndexCastOpGenericAdaptorBase>(m, "IndexCastOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::IndexCastOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::IndexCastOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_IndexCastOpAdaptor = nb::class_<mlir::arith::IndexCastOpAdaptor>(m, "IndexCastOpAdaptor")
.def(nb::init<mlir::arith::IndexCastOp>(), "op"_a)
.def("verify", &mlir::arith::IndexCastOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_IndexCastOp = nb::class_<mlir::arith::IndexCastOp,  mlir::OpState>(m, "IndexCastOp")
.def_static("attribute_names", &mlir::arith::IndexCastOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::IndexCastOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::IndexCastOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::IndexCastOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::IndexCastOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::IndexCastOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::IndexCastOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::IndexCastOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::IndexCastOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::IndexCastOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::IndexCastOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::IndexCastOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::IndexCastOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::IndexCastOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::IndexCastOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::IndexCastOp::fold, "adaptor"_a)
.def("infer_result_ranges", &mlir::arith::IndexCastOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("are_cast_compatible", &mlir::arith::IndexCastOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::IndexCastOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::IndexCastOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_IndexCastOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::IndexCastOp>>(m, "TypeIDResolver[arith::IndexCastOp]")
;

auto mlir_arith_detail_IndexCastUIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::IndexCastUIOpGenericAdaptorBase>(m, "IndexCastUIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::IndexCastUIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::IndexCastUIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_IndexCastUIOpAdaptor = nb::class_<mlir::arith::IndexCastUIOpAdaptor>(m, "IndexCastUIOpAdaptor")
.def(nb::init<mlir::arith::IndexCastUIOp>(), "op"_a)
.def("verify", &mlir::arith::IndexCastUIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_IndexCastUIOp = nb::class_<mlir::arith::IndexCastUIOp,  mlir::OpState>(m, "IndexCastUIOp")
.def_static("attribute_names", &mlir::arith::IndexCastUIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::IndexCastUIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::IndexCastUIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::IndexCastUIOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::IndexCastUIOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::IndexCastUIOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::IndexCastUIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::IndexCastUIOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::IndexCastUIOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::IndexCastUIOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::IndexCastUIOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::IndexCastUIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::IndexCastUIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::IndexCastUIOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::IndexCastUIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::IndexCastUIOp::fold, "adaptor"_a)
.def("infer_result_ranges", &mlir::arith::IndexCastUIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("are_cast_compatible", &mlir::arith::IndexCastUIOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::IndexCastUIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::IndexCastUIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_IndexCastUIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::IndexCastUIOp>>(m, "TypeIDResolver[arith::IndexCastUIOp]")
;

auto mlir_arith_detail_MaxNumFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MaxNumFOpGenericAdaptorBase>(m, "MaxNumFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::MaxNumFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::MaxNumFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_MaxNumFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::MaxNumFOpGenericAdaptorBase::Properties>(mlir_arith_detail_MaxNumFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::MaxNumFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_MaxNumFOpAdaptor = nb::class_<mlir::arith::MaxNumFOpAdaptor>(m, "MaxNumFOpAdaptor")
.def(nb::init<mlir::arith::MaxNumFOp>(), "op"_a)
.def("verify", &mlir::arith::MaxNumFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MaxNumFOp = nb::class_<mlir::arith::MaxNumFOp,  mlir::OpState>(m, "MaxNumFOp")
.def_static("attribute_names", &mlir::arith::MaxNumFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::MaxNumFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::MaxNumFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::MaxNumFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::MaxNumFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::MaxNumFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MaxNumFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MaxNumFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MaxNumFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MaxNumFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MaxNumFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MaxNumFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MaxNumFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MaxNumFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MaxNumFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::MaxNumFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::MaxNumFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::MaxNumFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::MaxNumFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::MaxNumFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::MaxNumFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::MaxNumFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::MaxNumFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::MaxNumFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::MaxNumFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::MaxNumFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::MaxNumFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::MaxNumFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::MaxNumFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::MaxNumFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::MaxNumFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::MaxNumFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MaxNumFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MaxNumFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MaxNumFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MaxNumFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MaxNumFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MaxNumFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MaxNumFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MaxNumFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::MaxNumFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::MaxNumFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MaxNumFOp::verifyInvariants)
.def("fold", &mlir::arith::MaxNumFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MaxNumFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::MaxNumFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MaxNumFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MaxNumFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MaxNumFOp>>(m, "TypeIDResolver[arith::MaxNumFOp]")
;

auto mlir_arith_detail_MaxSIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MaxSIOpGenericAdaptorBase>(m, "MaxSIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MaxSIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::MaxSIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_MaxSIOpAdaptor = nb::class_<mlir::arith::MaxSIOpAdaptor>(m, "MaxSIOpAdaptor")
.def(nb::init<mlir::arith::MaxSIOp>(), "op"_a)
.def("verify", &mlir::arith::MaxSIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MaxSIOp = nb::class_<mlir::arith::MaxSIOp,  mlir::OpState>(m, "MaxSIOp")
.def_static("attribute_names", &mlir::arith::MaxSIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::MaxSIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MaxSIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MaxSIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MaxSIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MaxSIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MaxSIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MaxSIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MaxSIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MaxSIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MaxSIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MaxSIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MaxSIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MaxSIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MaxSIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MaxSIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::MaxSIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MaxSIOp::verifyInvariants)
.def("fold", &mlir::arith::MaxSIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MaxSIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::MaxSIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::MaxSIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MaxSIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MaxSIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MaxSIOp>>(m, "TypeIDResolver[arith::MaxSIOp]")
;

auto mlir_arith_detail_MaxUIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MaxUIOpGenericAdaptorBase>(m, "MaxUIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MaxUIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::MaxUIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_MaxUIOpAdaptor = nb::class_<mlir::arith::MaxUIOpAdaptor>(m, "MaxUIOpAdaptor")
.def(nb::init<mlir::arith::MaxUIOp>(), "op"_a)
.def("verify", &mlir::arith::MaxUIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MaxUIOp = nb::class_<mlir::arith::MaxUIOp,  mlir::OpState>(m, "MaxUIOp")
.def_static("attribute_names", &mlir::arith::MaxUIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::MaxUIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MaxUIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MaxUIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MaxUIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MaxUIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MaxUIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MaxUIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MaxUIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MaxUIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MaxUIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MaxUIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MaxUIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MaxUIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MaxUIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MaxUIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::MaxUIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MaxUIOp::verifyInvariants)
.def("fold", &mlir::arith::MaxUIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MaxUIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::MaxUIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::MaxUIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MaxUIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MaxUIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MaxUIOp>>(m, "TypeIDResolver[arith::MaxUIOp]")
;

auto mlir_arith_detail_MaximumFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MaximumFOpGenericAdaptorBase>(m, "MaximumFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::MaximumFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::MaximumFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_MaximumFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::MaximumFOpGenericAdaptorBase::Properties>(mlir_arith_detail_MaximumFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::MaximumFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_MaximumFOpAdaptor = nb::class_<mlir::arith::MaximumFOpAdaptor>(m, "MaximumFOpAdaptor")
.def(nb::init<mlir::arith::MaximumFOp>(), "op"_a)
.def("verify", &mlir::arith::MaximumFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MaximumFOp = nb::class_<mlir::arith::MaximumFOp,  mlir::OpState>(m, "MaximumFOp")
.def_static("attribute_names", &mlir::arith::MaximumFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::MaximumFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::MaximumFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::MaximumFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::MaximumFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::MaximumFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MaximumFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MaximumFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MaximumFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MaximumFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MaximumFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MaximumFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MaximumFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MaximumFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MaximumFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::MaximumFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::MaximumFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::MaximumFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::MaximumFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::MaximumFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::MaximumFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::MaximumFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::MaximumFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::MaximumFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::MaximumFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::MaximumFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::MaximumFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::MaximumFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::MaximumFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::MaximumFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::MaximumFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::MaximumFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MaximumFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MaximumFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MaximumFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MaximumFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MaximumFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MaximumFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MaximumFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MaximumFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::MaximumFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::MaximumFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MaximumFOp::verifyInvariants)
.def("fold", &mlir::arith::MaximumFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MaximumFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::MaximumFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MaximumFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MaximumFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MaximumFOp>>(m, "TypeIDResolver[arith::MaximumFOp]")
;

auto mlir_arith_detail_MinNumFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MinNumFOpGenericAdaptorBase>(m, "MinNumFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::MinNumFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::MinNumFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_MinNumFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::MinNumFOpGenericAdaptorBase::Properties>(mlir_arith_detail_MinNumFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::MinNumFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_MinNumFOpAdaptor = nb::class_<mlir::arith::MinNumFOpAdaptor>(m, "MinNumFOpAdaptor")
.def(nb::init<mlir::arith::MinNumFOp>(), "op"_a)
.def("verify", &mlir::arith::MinNumFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MinNumFOp = nb::class_<mlir::arith::MinNumFOp,  mlir::OpState>(m, "MinNumFOp")
.def_static("attribute_names", &mlir::arith::MinNumFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::MinNumFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::MinNumFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::MinNumFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::MinNumFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::MinNumFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MinNumFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MinNumFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MinNumFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MinNumFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MinNumFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MinNumFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MinNumFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MinNumFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MinNumFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::MinNumFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::MinNumFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::MinNumFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::MinNumFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::MinNumFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::MinNumFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::MinNumFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::MinNumFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::MinNumFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::MinNumFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::MinNumFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::MinNumFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::MinNumFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::MinNumFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::MinNumFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::MinNumFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::MinNumFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MinNumFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MinNumFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MinNumFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MinNumFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MinNumFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MinNumFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MinNumFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MinNumFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::MinNumFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::MinNumFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MinNumFOp::verifyInvariants)
.def("fold", &mlir::arith::MinNumFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MinNumFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::MinNumFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MinNumFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MinNumFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MinNumFOp>>(m, "TypeIDResolver[arith::MinNumFOp]")
;

auto mlir_arith_detail_MinSIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MinSIOpGenericAdaptorBase>(m, "MinSIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MinSIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::MinSIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_MinSIOpAdaptor = nb::class_<mlir::arith::MinSIOpAdaptor>(m, "MinSIOpAdaptor")
.def(nb::init<mlir::arith::MinSIOp>(), "op"_a)
.def("verify", &mlir::arith::MinSIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MinSIOp = nb::class_<mlir::arith::MinSIOp,  mlir::OpState>(m, "MinSIOp")
.def_static("attribute_names", &mlir::arith::MinSIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::MinSIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MinSIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MinSIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MinSIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MinSIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MinSIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MinSIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MinSIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MinSIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MinSIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MinSIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MinSIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MinSIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MinSIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MinSIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::MinSIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MinSIOp::verifyInvariants)
.def("fold", &mlir::arith::MinSIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MinSIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::MinSIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::MinSIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MinSIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MinSIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MinSIOp>>(m, "TypeIDResolver[arith::MinSIOp]")
;

auto mlir_arith_detail_MinUIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MinUIOpGenericAdaptorBase>(m, "MinUIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MinUIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::MinUIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_MinUIOpAdaptor = nb::class_<mlir::arith::MinUIOpAdaptor>(m, "MinUIOpAdaptor")
.def(nb::init<mlir::arith::MinUIOp>(), "op"_a)
.def("verify", &mlir::arith::MinUIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MinUIOp = nb::class_<mlir::arith::MinUIOp,  mlir::OpState>(m, "MinUIOp")
.def_static("attribute_names", &mlir::arith::MinUIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::MinUIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MinUIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MinUIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MinUIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MinUIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MinUIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MinUIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MinUIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MinUIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MinUIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MinUIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MinUIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MinUIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MinUIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MinUIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::MinUIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MinUIOp::verifyInvariants)
.def("fold", &mlir::arith::MinUIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MinUIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::MinUIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::MinUIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MinUIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MinUIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MinUIOp>>(m, "TypeIDResolver[arith::MinUIOp]")
;

auto mlir_arith_detail_MinimumFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MinimumFOpGenericAdaptorBase>(m, "MinimumFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::MinimumFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::MinimumFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_MinimumFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::MinimumFOpGenericAdaptorBase::Properties>(mlir_arith_detail_MinimumFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::MinimumFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_MinimumFOpAdaptor = nb::class_<mlir::arith::MinimumFOpAdaptor>(m, "MinimumFOpAdaptor")
.def(nb::init<mlir::arith::MinimumFOp>(), "op"_a)
.def("verify", &mlir::arith::MinimumFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MinimumFOp = nb::class_<mlir::arith::MinimumFOp,  mlir::OpState>(m, "MinimumFOp")
.def_static("attribute_names", &mlir::arith::MinimumFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::MinimumFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::MinimumFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::MinimumFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::MinimumFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::MinimumFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MinimumFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MinimumFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MinimumFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MinimumFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MinimumFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MinimumFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MinimumFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MinimumFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MinimumFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::MinimumFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::MinimumFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::MinimumFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::MinimumFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::MinimumFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::MinimumFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::MinimumFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::MinimumFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::MinimumFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::MinimumFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::MinimumFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::MinimumFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::MinimumFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::MinimumFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::MinimumFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::MinimumFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::MinimumFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MinimumFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MinimumFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MinimumFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MinimumFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MinimumFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MinimumFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MinimumFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MinimumFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::MinimumFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::MinimumFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MinimumFOp::verifyInvariants)
.def("fold", &mlir::arith::MinimumFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MinimumFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::MinimumFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MinimumFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MinimumFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MinimumFOp>>(m, "TypeIDResolver[arith::MinimumFOp]")
;

auto mlir_arith_detail_MulFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MulFOpGenericAdaptorBase>(m, "MulFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::MulFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::MulFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MulFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::MulFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::MulFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::MulFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::MulFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::MulFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::MulFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_MulFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::MulFOpGenericAdaptorBase::Properties>(mlir_arith_detail_MulFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::MulFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::MulFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::MulFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::MulFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::MulFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::MulFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_MulFOpAdaptor = nb::class_<mlir::arith::MulFOpAdaptor>(m, "MulFOpAdaptor")
.def(nb::init<mlir::arith::MulFOp>(), "op"_a)
.def("verify", &mlir::arith::MulFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MulFOp = nb::class_<mlir::arith::MulFOp,  mlir::OpState>(m, "MulFOp")
.def_static("attribute_names", &mlir::arith::MulFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::MulFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::MulFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::MulFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::MulFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::MulFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MulFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MulFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MulFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MulFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MulFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MulFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MulFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MulFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MulFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::MulFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::MulFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::MulFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::MulFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::MulFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::MulFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::MulFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::MulFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::MulFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::MulFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::MulFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::MulFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::MulFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::MulFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::MulFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::MulFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::MulFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MulFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MulFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::MulFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MulFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MulFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::MulFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MulFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MulFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::MulFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::MulFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MulFOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::MulFOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::MulFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MulFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::MulFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MulFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MulFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MulFOp>>(m, "TypeIDResolver[arith::MulFOp]")
;

auto mlir_arith_detail_MulIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MulIOpGenericAdaptorBase>(m, "MulIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::MulIOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::MulIOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MulIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::MulIOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::MulIOpGenericAdaptorBase::getAttributes)
.def_prop_ro("overflow_flags_attr", &mlir::arith::detail::MulIOpGenericAdaptorBase::getOverflowFlagsAttr)
.def_prop_ro("overflow_flags", &mlir::arith::detail::MulIOpGenericAdaptorBase::getOverflowFlags)
;

auto mlir_arith_detail_MulIOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::MulIOpGenericAdaptorBase::Properties>(mlir_arith_detail_MulIOpGenericAdaptorBase, "Properties")
.def_prop_ro("overflow_flags", &mlir::arith::detail::MulIOpGenericAdaptorBase::Properties::getOverflowFlags)
.def("set_overflow_flags", &mlir::arith::detail::MulIOpGenericAdaptorBase::Properties::setOverflowFlags, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::MulIOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::MulIOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_MulIOpAdaptor = nb::class_<mlir::arith::MulIOpAdaptor>(m, "MulIOpAdaptor")
.def(nb::init<mlir::arith::MulIOp>(), "op"_a)
.def("verify", &mlir::arith::MulIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MulIOp = nb::class_<mlir::arith::MulIOp,  mlir::OpState>(m, "MulIOp")
.def_static("attribute_names", &mlir::arith::MulIOp::getAttributeNames)
.def_prop_ro("overflow_flags_attr_name", [](mlir::arith::MulIOp& self){ return self.getOverflowFlagsAttrName(); })
.def_static("get_overflow_flags_attr_name", [](mlir::OperationName name){ return mlir::arith::MulIOp::getOverflowFlagsAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::MulIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MulIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MulIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MulIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MulIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MulIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MulIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MulIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MulIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::MulIOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::MulIOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::MulIOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::MulIOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::MulIOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::MulIOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::MulIOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::MulIOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::MulIOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::MulIOp::writeProperties, "writer"_a)
.def_prop_ro("overflow_flags_attr", &mlir::arith::MulIOp::getOverflowFlagsAttr)
.def_prop_ro("overflow_flags", &mlir::arith::MulIOp::getOverflowFlags)
.def("set_overflow_flags_attr", &mlir::arith::MulIOp::setOverflowFlagsAttr, "attr"_a)
.def("set_overflow_flags", &mlir::arith::MulIOp::setOverflowFlags, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::MulIOp::build(odsBuilder, odsState, result, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::MulIOp::build(odsBuilder, odsState, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::MulIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::MulIOp::build(odsBuilder, odsState, result, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::MulIOp::build(odsBuilder, odsState, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::MulIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MulIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MulIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::MulIOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::MulIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MulIOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::MulIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::MulIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::MulIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("get_asm_result_names", &mlir::arith::MulIOp::getAsmResultNames, "set_name_fn"_a)
.def("infer_result_ranges", &mlir::arith::MulIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::MulIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MulIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MulIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MulIOp>>(m, "TypeIDResolver[arith::MulIOp]")
;

auto mlir_arith_detail_MulSIExtendedOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MulSIExtendedOpGenericAdaptorBase>(m, "MulSIExtendedOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MulSIExtendedOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::MulSIExtendedOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_MulSIExtendedOpAdaptor = nb::class_<mlir::arith::MulSIExtendedOpAdaptor>(m, "MulSIExtendedOpAdaptor")
.def(nb::init<mlir::arith::MulSIExtendedOp>(), "op"_a)
.def("verify", &mlir::arith::MulSIExtendedOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MulSIExtendedOp = nb::class_<mlir::arith::MulSIExtendedOp,  mlir::OpState>(m, "MulSIExtendedOp")
.def_static("attribute_names", &mlir::arith::MulSIExtendedOp::getAttributeNames)
.def("get_asm_result_names", &mlir::arith::MulSIExtendedOp::getAsmResultNames, "set_name_fn"_a)
.def_static("operation_name", &mlir::arith::MulSIExtendedOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MulSIExtendedOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MulSIExtendedOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MulSIExtendedOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MulSIExtendedOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MulSIExtendedOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MulSIExtendedOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MulSIExtendedOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MulSIExtendedOp::getODSResults, "index"_a)
.def_prop_ro("low", &mlir::arith::MulSIExtendedOp::getLow)
.def_prop_ro("high", &mlir::arith::MulSIExtendedOp::getHigh)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type low, mlir::Type high, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MulSIExtendedOp::build(odsBuilder, odsState, low, high, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "low"_a, "high"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MulSIExtendedOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MulSIExtendedOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MulSIExtendedOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MulSIExtendedOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::MulSIExtendedOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MulSIExtendedOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::MulSIExtendedOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::MulSIExtendedOp::fold, "adaptor"_a, "results"_a)
.def_static("infer_return_types", &mlir::arith::MulSIExtendedOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::MulSIExtendedOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MulSIExtendedOp::getEffects, "effects"_a)
.def_prop_ro("shape_for_unroll", &mlir::arith::MulSIExtendedOp::getShapeForUnroll)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MulSIExtendedOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MulSIExtendedOp>>(m, "TypeIDResolver[arith::MulSIExtendedOp]")
;

auto mlir_arith_detail_MulUIExtendedOpGenericAdaptorBase = nb::class_<mlir::arith::detail::MulUIExtendedOpGenericAdaptorBase>(m, "MulUIExtendedOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::MulUIExtendedOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::MulUIExtendedOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_MulUIExtendedOpAdaptor = nb::class_<mlir::arith::MulUIExtendedOpAdaptor>(m, "MulUIExtendedOpAdaptor")
.def(nb::init<mlir::arith::MulUIExtendedOp>(), "op"_a)
.def("verify", &mlir::arith::MulUIExtendedOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_MulUIExtendedOp = nb::class_<mlir::arith::MulUIExtendedOp,  mlir::OpState>(m, "MulUIExtendedOp")
.def_static("attribute_names", &mlir::arith::MulUIExtendedOp::getAttributeNames)
.def("get_asm_result_names", &mlir::arith::MulUIExtendedOp::getAsmResultNames, "set_name_fn"_a)
.def_static("operation_name", &mlir::arith::MulUIExtendedOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::MulUIExtendedOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::MulUIExtendedOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::MulUIExtendedOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::MulUIExtendedOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::MulUIExtendedOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::MulUIExtendedOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::MulUIExtendedOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::MulUIExtendedOp::getODSResults, "index"_a)
.def_prop_ro("low", &mlir::arith::MulUIExtendedOp::getLow)
.def_prop_ro("high", &mlir::arith::MulUIExtendedOp::getHigh)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type low, mlir::Type high, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MulUIExtendedOp::build(odsBuilder, odsState, low, high, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "low"_a, "high"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MulUIExtendedOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::MulUIExtendedOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MulUIExtendedOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::MulUIExtendedOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::MulUIExtendedOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::MulUIExtendedOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::MulUIExtendedOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::MulUIExtendedOp::fold, "adaptor"_a, "results"_a)
.def_static("infer_return_types", &mlir::arith::MulUIExtendedOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::MulUIExtendedOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::MulUIExtendedOp::getEffects, "effects"_a)
.def_prop_ro("shape_for_unroll", &mlir::arith::MulUIExtendedOp::getShapeForUnroll)
;

auto mlir_detail_TypeIDResolver___mlir_arith_MulUIExtendedOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::MulUIExtendedOp>>(m, "TypeIDResolver[arith::MulUIExtendedOp]")
;

auto mlir_arith_detail_NegFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::NegFOpGenericAdaptorBase>(m, "NegFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::NegFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::NegFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::NegFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::NegFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::NegFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::NegFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::NegFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::NegFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::NegFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_NegFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::NegFOpGenericAdaptorBase::Properties>(mlir_arith_detail_NegFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::NegFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::NegFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::NegFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::NegFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::NegFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::NegFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_NegFOpAdaptor = nb::class_<mlir::arith::NegFOpAdaptor>(m, "NegFOpAdaptor")
.def(nb::init<mlir::arith::NegFOp>(), "op"_a)
.def("verify", &mlir::arith::NegFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_NegFOp = nb::class_<mlir::arith::NegFOp,  mlir::OpState>(m, "NegFOp")
.def_static("attribute_names", &mlir::arith::NegFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::NegFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::NegFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::NegFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::NegFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::NegFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::NegFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::NegFOp::getODSOperands, "index"_a)
.def_prop_ro("operand", &mlir::arith::NegFOp::getOperand)
.def_prop_ro("operand_mutable", &mlir::arith::NegFOp::getOperandMutable)
.def("get_ods_result_index_and_length", &mlir::arith::NegFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::NegFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::NegFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::NegFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::NegFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::NegFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::NegFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::NegFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::NegFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::NegFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::NegFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::NegFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::NegFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::NegFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::NegFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::NegFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::NegFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::NegFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::NegFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::NegFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value operand, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::NegFOp::build(odsBuilder, odsState, result, operand, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "operand"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value operand, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::NegFOp::build(odsBuilder, odsState, operand, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "operand"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value operand, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::NegFOp::build(odsBuilder, odsState, resultTypes, operand, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "operand"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value operand, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::NegFOp::build(odsBuilder, odsState, result, operand, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "operand"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value operand, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::NegFOp::build(odsBuilder, odsState, operand, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "operand"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value operand, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::NegFOp::build(odsBuilder, odsState, resultTypes, operand, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "operand"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::NegFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::NegFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::NegFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::NegFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::NegFOp::verifyInvariants)
.def("fold", &mlir::arith::NegFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::NegFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::NegFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::NegFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_NegFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::NegFOp>>(m, "TypeIDResolver[arith::NegFOp]")
;

auto mlir_arith_detail_OrIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::OrIOpGenericAdaptorBase>(m, "OrIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::OrIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::OrIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_OrIOpAdaptor = nb::class_<mlir::arith::OrIOpAdaptor>(m, "OrIOpAdaptor")
.def(nb::init<mlir::arith::OrIOp>(), "op"_a)
.def("verify", &mlir::arith::OrIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_OrIOp = nb::class_<mlir::arith::OrIOp,  mlir::OpState>(m, "OrIOp")
.def_static("attribute_names", &mlir::arith::OrIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::OrIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::OrIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::OrIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::OrIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::OrIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::OrIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::OrIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::OrIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::OrIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::OrIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::OrIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::OrIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::OrIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::OrIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::OrIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::OrIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::OrIOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::OrIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::OrIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::OrIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::OrIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::OrIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::OrIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_OrIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::OrIOp>>(m, "TypeIDResolver[arith::OrIOp]")
;

auto mlir_arith_detail_RemFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::RemFOpGenericAdaptorBase>(m, "RemFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::RemFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::RemFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::RemFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::RemFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::RemFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::RemFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::RemFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::RemFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::RemFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_RemFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::RemFOpGenericAdaptorBase::Properties>(mlir_arith_detail_RemFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::RemFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::RemFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::RemFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::RemFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::RemFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::RemFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_RemFOpAdaptor = nb::class_<mlir::arith::RemFOpAdaptor>(m, "RemFOpAdaptor")
.def(nb::init<mlir::arith::RemFOp>(), "op"_a)
.def("verify", &mlir::arith::RemFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_RemFOp = nb::class_<mlir::arith::RemFOp,  mlir::OpState>(m, "RemFOp")
.def_static("attribute_names", &mlir::arith::RemFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::RemFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::RemFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::RemFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::RemFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::RemFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::RemFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::RemFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::RemFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::RemFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::RemFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::RemFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::RemFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::RemFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::RemFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::RemFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::RemFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::RemFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::RemFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::RemFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::RemFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::RemFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::RemFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::RemFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::RemFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::RemFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::RemFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::RemFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::RemFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::RemFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::RemFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::RemFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::RemFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::RemFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::RemFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::RemFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::RemFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::RemFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::RemFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::RemFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::RemFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::RemFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::RemFOp::verifyInvariants)
.def("fold", &mlir::arith::RemFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::RemFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::RemFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::RemFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_RemFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::RemFOp>>(m, "TypeIDResolver[arith::RemFOp]")
;

auto mlir_arith_detail_RemSIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::RemSIOpGenericAdaptorBase>(m, "RemSIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::RemSIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::RemSIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_RemSIOpAdaptor = nb::class_<mlir::arith::RemSIOpAdaptor>(m, "RemSIOpAdaptor")
.def(nb::init<mlir::arith::RemSIOp>(), "op"_a)
.def("verify", &mlir::arith::RemSIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_RemSIOp = nb::class_<mlir::arith::RemSIOp,  mlir::OpState>(m, "RemSIOp")
.def_static("attribute_names", &mlir::arith::RemSIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::RemSIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::RemSIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::RemSIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::RemSIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::RemSIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::RemSIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::RemSIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::RemSIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::RemSIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::RemSIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::RemSIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::RemSIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::RemSIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::RemSIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::RemSIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::RemSIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::RemSIOp::verifyInvariants)
.def("fold", &mlir::arith::RemSIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::RemSIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::RemSIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::RemSIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::RemSIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_RemSIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::RemSIOp>>(m, "TypeIDResolver[arith::RemSIOp]")
;

auto mlir_arith_detail_RemUIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::RemUIOpGenericAdaptorBase>(m, "RemUIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::RemUIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::RemUIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_RemUIOpAdaptor = nb::class_<mlir::arith::RemUIOpAdaptor>(m, "RemUIOpAdaptor")
.def(nb::init<mlir::arith::RemUIOp>(), "op"_a)
.def("verify", &mlir::arith::RemUIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_RemUIOp = nb::class_<mlir::arith::RemUIOp,  mlir::OpState>(m, "RemUIOp")
.def_static("attribute_names", &mlir::arith::RemUIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::RemUIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::RemUIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::RemUIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::RemUIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::RemUIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::RemUIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::RemUIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::RemUIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::RemUIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::RemUIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::RemUIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::RemUIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::RemUIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::RemUIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::RemUIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::RemUIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::RemUIOp::verifyInvariants)
.def("fold", &mlir::arith::RemUIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::RemUIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::RemUIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::RemUIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::RemUIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_RemUIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::RemUIOp>>(m, "TypeIDResolver[arith::RemUIOp]")
;

auto mlir_arith_detail_SIToFPOpGenericAdaptorBase = nb::class_<mlir::arith::detail::SIToFPOpGenericAdaptorBase>(m, "SIToFPOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::SIToFPOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::SIToFPOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_SIToFPOpAdaptor = nb::class_<mlir::arith::SIToFPOpAdaptor>(m, "SIToFPOpAdaptor")
.def(nb::init<mlir::arith::SIToFPOp>(), "op"_a)
.def("verify", &mlir::arith::SIToFPOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_SIToFPOp = nb::class_<mlir::arith::SIToFPOp,  mlir::OpState>(m, "SIToFPOp")
.def_static("attribute_names", &mlir::arith::SIToFPOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::SIToFPOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::SIToFPOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::SIToFPOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::SIToFPOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::SIToFPOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::SIToFPOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::SIToFPOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::SIToFPOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::SIToFPOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::SIToFPOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::SIToFPOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::SIToFPOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::SIToFPOp::verifyInvariants)
.def("fold", &mlir::arith::SIToFPOp::fold, "adaptor"_a)
.def_static("are_cast_compatible", &mlir::arith::SIToFPOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::SIToFPOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::SIToFPOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_SIToFPOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::SIToFPOp>>(m, "TypeIDResolver[arith::SIToFPOp]")
;

auto mlir_arith_detail_ShLIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::ShLIOpGenericAdaptorBase>(m, "ShLIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::ShLIOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::ShLIOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::ShLIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::ShLIOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::ShLIOpGenericAdaptorBase::getAttributes)
.def_prop_ro("overflow_flags_attr", &mlir::arith::detail::ShLIOpGenericAdaptorBase::getOverflowFlagsAttr)
.def_prop_ro("overflow_flags", &mlir::arith::detail::ShLIOpGenericAdaptorBase::getOverflowFlags)
;

auto mlir_arith_detail_ShLIOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::ShLIOpGenericAdaptorBase::Properties>(mlir_arith_detail_ShLIOpGenericAdaptorBase, "Properties")
.def_prop_ro("overflow_flags", &mlir::arith::detail::ShLIOpGenericAdaptorBase::Properties::getOverflowFlags)
.def("set_overflow_flags", &mlir::arith::detail::ShLIOpGenericAdaptorBase::Properties::setOverflowFlags, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::ShLIOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::ShLIOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_ShLIOpAdaptor = nb::class_<mlir::arith::ShLIOpAdaptor>(m, "ShLIOpAdaptor")
.def(nb::init<mlir::arith::ShLIOp>(), "op"_a)
.def("verify", &mlir::arith::ShLIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_ShLIOp = nb::class_<mlir::arith::ShLIOp,  mlir::OpState>(m, "ShLIOp")
.def_static("attribute_names", &mlir::arith::ShLIOp::getAttributeNames)
.def_prop_ro("overflow_flags_attr_name", [](mlir::arith::ShLIOp& self){ return self.getOverflowFlagsAttrName(); })
.def_static("get_overflow_flags_attr_name", [](mlir::OperationName name){ return mlir::arith::ShLIOp::getOverflowFlagsAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::ShLIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::ShLIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::ShLIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::ShLIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::ShLIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::ShLIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::ShLIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::ShLIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::ShLIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::ShLIOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::ShLIOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::ShLIOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::ShLIOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::ShLIOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::ShLIOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::ShLIOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::ShLIOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::ShLIOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::ShLIOp::writeProperties, "writer"_a)
.def_prop_ro("overflow_flags_attr", &mlir::arith::ShLIOp::getOverflowFlagsAttr)
.def_prop_ro("overflow_flags", &mlir::arith::ShLIOp::getOverflowFlags)
.def("set_overflow_flags_attr", &mlir::arith::ShLIOp::setOverflowFlagsAttr, "attr"_a)
.def("set_overflow_flags", &mlir::arith::ShLIOp::setOverflowFlags, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::ShLIOp::build(odsBuilder, odsState, result, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::ShLIOp::build(odsBuilder, odsState, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::ShLIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::ShLIOp::build(odsBuilder, odsState, result, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::ShLIOp::build(odsBuilder, odsState, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::ShLIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ShLIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ShLIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::ShLIOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::ShLIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::ShLIOp::verifyInvariants)
.def("fold", &mlir::arith::ShLIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::ShLIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::ShLIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::ShLIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::ShLIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_ShLIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::ShLIOp>>(m, "TypeIDResolver[arith::ShLIOp]")
;

auto mlir_arith_detail_ShRSIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::ShRSIOpGenericAdaptorBase>(m, "ShRSIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::ShRSIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::ShRSIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_ShRSIOpAdaptor = nb::class_<mlir::arith::ShRSIOpAdaptor>(m, "ShRSIOpAdaptor")
.def(nb::init<mlir::arith::ShRSIOp>(), "op"_a)
.def("verify", &mlir::arith::ShRSIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_ShRSIOp = nb::class_<mlir::arith::ShRSIOp,  mlir::OpState>(m, "ShRSIOp")
.def_static("attribute_names", &mlir::arith::ShRSIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::ShRSIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::ShRSIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::ShRSIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::ShRSIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::ShRSIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::ShRSIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::ShRSIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::ShRSIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::ShRSIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::ShRSIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::ShRSIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::ShRSIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::ShRSIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ShRSIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ShRSIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::ShRSIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::ShRSIOp::verifyInvariants)
.def("fold", &mlir::arith::ShRSIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::ShRSIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::ShRSIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::ShRSIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::ShRSIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_ShRSIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::ShRSIOp>>(m, "TypeIDResolver[arith::ShRSIOp]")
;

auto mlir_arith_detail_ShRUIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::ShRUIOpGenericAdaptorBase>(m, "ShRUIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::ShRUIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::ShRUIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_ShRUIOpAdaptor = nb::class_<mlir::arith::ShRUIOpAdaptor>(m, "ShRUIOpAdaptor")
.def(nb::init<mlir::arith::ShRUIOp>(), "op"_a)
.def("verify", &mlir::arith::ShRUIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_ShRUIOp = nb::class_<mlir::arith::ShRUIOp,  mlir::OpState>(m, "ShRUIOp")
.def_static("attribute_names", &mlir::arith::ShRUIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::ShRUIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::ShRUIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::ShRUIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::ShRUIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::ShRUIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::ShRUIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::ShRUIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::ShRUIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::ShRUIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::ShRUIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::ShRUIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::ShRUIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::ShRUIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ShRUIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::ShRUIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::ShRUIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::ShRUIOp::verifyInvariants)
.def("fold", &mlir::arith::ShRUIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::ShRUIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::ShRUIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::ShRUIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::ShRUIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_ShRUIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::ShRUIOp>>(m, "TypeIDResolver[arith::ShRUIOp]")
;

auto mlir_arith_detail_SubFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::SubFOpGenericAdaptorBase>(m, "SubFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::SubFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::SubFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::SubFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::SubFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::SubFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::SubFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::SubFOpGenericAdaptorBase::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::detail::SubFOpGenericAdaptorBase::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::detail::SubFOpGenericAdaptorBase::getDenormal)
;

auto mlir_arith_detail_SubFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::SubFOpGenericAdaptorBase::Properties>(mlir_arith_detail_SubFOpGenericAdaptorBase, "Properties")
.def_prop_ro("denormal", &mlir::arith::detail::SubFOpGenericAdaptorBase::Properties::getDenormal)
.def("set_denormal", &mlir::arith::detail::SubFOpGenericAdaptorBase::Properties::setDenormal, "prop_value"_a)
.def_prop_ro("fastmath", &mlir::arith::detail::SubFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::SubFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::SubFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::SubFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_SubFOpAdaptor = nb::class_<mlir::arith::SubFOpAdaptor>(m, "SubFOpAdaptor")
.def(nb::init<mlir::arith::SubFOp>(), "op"_a)
.def("verify", &mlir::arith::SubFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_SubFOp = nb::class_<mlir::arith::SubFOp,  mlir::OpState>(m, "SubFOp")
.def_static("attribute_names", &mlir::arith::SubFOp::getAttributeNames)
.def_prop_ro("denormal_attr_name", [](mlir::arith::SubFOp& self){ return self.getDenormalAttrName(); })
.def_static("get_denormal_attr_name", [](mlir::OperationName name){ return mlir::arith::SubFOp::getDenormalAttrName(name); }, "name"_a)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::SubFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::SubFOp::getFastmathAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::SubFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::SubFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::SubFOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::SubFOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::SubFOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::SubFOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::SubFOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::SubFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::SubFOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::SubFOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::SubFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::SubFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::SubFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::SubFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::SubFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::SubFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::SubFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::SubFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::SubFOp::writeProperties, "writer"_a)
.def_prop_ro("fastmath_attr", &mlir::arith::SubFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::SubFOp::getFastmath)
.def_prop_ro("denormal_attr", &mlir::arith::SubFOp::getDenormalAttr)
.def_prop_ro("denormal", &mlir::arith::SubFOp::getDenormal)
.def("set_fastmath_attr", &mlir::arith::SubFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::SubFOp::setFastmath, "attr_value"_a)
.def("set_denormal_attr", &mlir::arith::SubFOp::setDenormalAttr, "attr"_a)
.def("set_denormal", &mlir::arith::SubFOp::setDenormal, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::SubFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::SubFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlagsAttr fastmath, mlir::arith::DenormalModeAttr denormal){ return mlir::arith::SubFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::SubFOp::build(odsBuilder, odsState, result, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::SubFOp::build(odsBuilder, odsState, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::FastMathFlags fastmath, mlir::arith::DenormalMode denormal){ return mlir::arith::SubFOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, fastmath, denormal); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "fastmath"_a, "denormal"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::SubFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::SubFOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::SubFOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::SubFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::SubFOp::verifyInvariants)
.def("fold", &mlir::arith::SubFOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::SubFOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::arith::SubFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::SubFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_SubFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::SubFOp>>(m, "TypeIDResolver[arith::SubFOp]")
;

auto mlir_arith_detail_SubIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::SubIOpGenericAdaptorBase>(m, "SubIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::SubIOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::SubIOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::SubIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::SubIOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::SubIOpGenericAdaptorBase::getAttributes)
.def_prop_ro("overflow_flags_attr", &mlir::arith::detail::SubIOpGenericAdaptorBase::getOverflowFlagsAttr)
.def_prop_ro("overflow_flags", &mlir::arith::detail::SubIOpGenericAdaptorBase::getOverflowFlags)
;

auto mlir_arith_detail_SubIOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::SubIOpGenericAdaptorBase::Properties>(mlir_arith_detail_SubIOpGenericAdaptorBase, "Properties")
.def_prop_ro("overflow_flags", &mlir::arith::detail::SubIOpGenericAdaptorBase::Properties::getOverflowFlags)
.def("set_overflow_flags", &mlir::arith::detail::SubIOpGenericAdaptorBase::Properties::setOverflowFlags, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::SubIOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::SubIOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_SubIOpAdaptor = nb::class_<mlir::arith::SubIOpAdaptor>(m, "SubIOpAdaptor")
.def(nb::init<mlir::arith::SubIOp>(), "op"_a)
.def("verify", &mlir::arith::SubIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_SubIOp = nb::class_<mlir::arith::SubIOp,  mlir::OpState>(m, "SubIOp")
.def_static("attribute_names", &mlir::arith::SubIOp::getAttributeNames)
.def_prop_ro("overflow_flags_attr_name", [](mlir::arith::SubIOp& self){ return self.getOverflowFlagsAttrName(); })
.def_static("get_overflow_flags_attr_name", [](mlir::OperationName name){ return mlir::arith::SubIOp::getOverflowFlagsAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::SubIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::SubIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::SubIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::SubIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::SubIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::SubIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::SubIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::SubIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::SubIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::SubIOp::getResult)
.def_static("set_properties_from_attr", &mlir::arith::SubIOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::SubIOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::SubIOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::SubIOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::SubIOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::SubIOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::SubIOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::SubIOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::SubIOp::writeProperties, "writer"_a)
.def_prop_ro("overflow_flags_attr", &mlir::arith::SubIOp::getOverflowFlagsAttr)
.def_prop_ro("overflow_flags", &mlir::arith::SubIOp::getOverflowFlags)
.def("set_overflow_flags_attr", &mlir::arith::SubIOp::setOverflowFlagsAttr, "attr"_a)
.def("set_overflow_flags", &mlir::arith::SubIOp::setOverflowFlags, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::SubIOp::build(odsBuilder, odsState, result, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::SubIOp::build(odsBuilder, odsState, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlagsAttr overflowFlags){ return mlir::arith::SubIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::SubIOp::build(odsBuilder, odsState, result, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::SubIOp::build(odsBuilder, odsState, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs, mlir::arith::IntegerOverflowFlags overflowFlags){ return mlir::arith::SubIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs, overflowFlags); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a, "overflow_flags"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::SubIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::SubIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("populate_default_properties", &mlir::arith::SubIOp::populateDefaultProperties, "op_name"_a, "properties"_a)
.def("verify_invariants_impl", &mlir::arith::SubIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::SubIOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::SubIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::SubIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::SubIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::SubIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::SubIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::SubIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_SubIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::SubIOp>>(m, "TypeIDResolver[arith::SubIOp]")
;

auto mlir_arith_detail_TruncFOpGenericAdaptorBase = nb::class_<mlir::arith::detail::TruncFOpGenericAdaptorBase>(m, "TruncFOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::arith::detail::TruncFOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::arith::TruncFOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::TruncFOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::arith::detail::TruncFOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::arith::detail::TruncFOpGenericAdaptorBase::getAttributes)
.def_prop_ro("roundingmode_attr", &mlir::arith::detail::TruncFOpGenericAdaptorBase::getRoundingmodeAttr)
.def_prop_ro("roundingmode", &mlir::arith::detail::TruncFOpGenericAdaptorBase::getRoundingmode)
.def_prop_ro("fastmath_attr", &mlir::arith::detail::TruncFOpGenericAdaptorBase::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::detail::TruncFOpGenericAdaptorBase::getFastmath)
;

auto mlir_arith_detail_TruncFOpGenericAdaptorBase_Properties = nb::class_<mlir::arith::detail::TruncFOpGenericAdaptorBase::Properties>(mlir_arith_detail_TruncFOpGenericAdaptorBase, "Properties")
.def_prop_ro("fastmath", &mlir::arith::detail::TruncFOpGenericAdaptorBase::Properties::getFastmath)
.def("set_fastmath", &mlir::arith::detail::TruncFOpGenericAdaptorBase::Properties::setFastmath, "prop_value"_a)
.def_prop_ro("roundingmode", &mlir::arith::detail::TruncFOpGenericAdaptorBase::Properties::getRoundingmode)
.def("set_roundingmode", &mlir::arith::detail::TruncFOpGenericAdaptorBase::Properties::setRoundingmode, "prop_value"_a)
.def("__eq__", &mlir::arith::detail::TruncFOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::arith::detail::TruncFOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_arith_TruncFOpAdaptor = nb::class_<mlir::arith::TruncFOpAdaptor>(m, "TruncFOpAdaptor")
.def(nb::init<mlir::arith::TruncFOp>(), "op"_a)
.def("verify", &mlir::arith::TruncFOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_TruncFOp = nb::class_<mlir::arith::TruncFOp,  mlir::OpState>(m, "TruncFOp")
.def_static("attribute_names", &mlir::arith::TruncFOp::getAttributeNames)
.def_prop_ro("fastmath_attr_name", [](mlir::arith::TruncFOp& self){ return self.getFastmathAttrName(); })
.def_static("get_fastmath_attr_name", [](mlir::OperationName name){ return mlir::arith::TruncFOp::getFastmathAttrName(name); }, "name"_a)
.def_prop_ro("roundingmode_attr_name", [](mlir::arith::TruncFOp& self){ return self.getRoundingmodeAttrName(); })
.def_static("get_roundingmode_attr_name", [](mlir::OperationName name){ return mlir::arith::TruncFOp::getRoundingmodeAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::arith::TruncFOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::TruncFOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::TruncFOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::TruncFOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::TruncFOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::TruncFOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::TruncFOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::TruncFOp::getOut)
.def_static("set_properties_from_attr", &mlir::arith::TruncFOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::arith::TruncFOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::arith::TruncFOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::arith::TruncFOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::arith::TruncFOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::arith::TruncFOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::arith::TruncFOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::arith::TruncFOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::arith::TruncFOp::writeProperties, "writer"_a)
.def_prop_ro("roundingmode_attr", &mlir::arith::TruncFOp::getRoundingmodeAttr)
.def_prop_ro("roundingmode", &mlir::arith::TruncFOp::getRoundingmode)
.def_prop_ro("fastmath_attr", &mlir::arith::TruncFOp::getFastmathAttr)
.def_prop_ro("fastmath", &mlir::arith::TruncFOp::getFastmath)
.def("set_roundingmode_attr", &mlir::arith::TruncFOp::setRoundingmodeAttr, "attr"_a)
.def("set_roundingmode", &mlir::arith::TruncFOp::setRoundingmode, "attr_value"_a)
.def("set_fastmath_attr", &mlir::arith::TruncFOp::setFastmathAttr, "attr"_a)
.def("set_fastmath", &mlir::arith::TruncFOp::setFastmath, "attr_value"_a)
.def("remove_roundingmode_attr", &mlir::arith::TruncFOp::removeRoundingmodeAttr)
.def("remove_fastmath_attr", &mlir::arith::TruncFOp::removeFastmathAttr)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::TruncFOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in, mlir::arith::RoundingModeAttr roundingmode, mlir::arith::FastMathFlagsAttr fastmath){ return mlir::arith::TruncFOp::build(odsBuilder, odsState, out, in, roundingmode, fastmath); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a, "roundingmode"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in, mlir::arith::RoundingModeAttr roundingmode, mlir::arith::FastMathFlagsAttr fastmath){ return mlir::arith::TruncFOp::build(odsBuilder, odsState, resultTypes, in, roundingmode, fastmath); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a, "roundingmode"_a, "fastmath"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::TruncFOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::TruncFOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::TruncFOp::verifyInvariants)
.def("verify", &mlir::arith::TruncFOp::verify)
.def("fold", &mlir::arith::TruncFOp::fold, "adaptor"_a)
.def_static("are_cast_compatible", &mlir::arith::TruncFOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::TruncFOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::TruncFOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_TruncFOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::TruncFOp>>(m, "TypeIDResolver[arith::TruncFOp]")
;

auto mlir_arith_detail_TruncIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::TruncIOpGenericAdaptorBase>(m, "TruncIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::TruncIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::TruncIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_TruncIOpAdaptor = nb::class_<mlir::arith::TruncIOpAdaptor>(m, "TruncIOpAdaptor")
.def(nb::init<mlir::arith::TruncIOp>(), "op"_a)
.def("verify", &mlir::arith::TruncIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_TruncIOp = nb::class_<mlir::arith::TruncIOp,  mlir::OpState>(m, "TruncIOp")
.def_static("attribute_names", &mlir::arith::TruncIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::TruncIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::TruncIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::TruncIOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::TruncIOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::TruncIOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::TruncIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::TruncIOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::TruncIOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::TruncIOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::TruncIOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::TruncIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::TruncIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::TruncIOp::verifyInvariants)
.def("verify", &mlir::arith::TruncIOp::verify)
.def_static("get_canonicalization_patterns", &mlir::arith::TruncIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::TruncIOp::fold, "adaptor"_a)
.def("infer_result_ranges", &mlir::arith::TruncIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("are_cast_compatible", &mlir::arith::TruncIOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::TruncIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::TruncIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_TruncIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::TruncIOp>>(m, "TypeIDResolver[arith::TruncIOp]")
;

auto mlir_arith_detail_UIToFPOpGenericAdaptorBase = nb::class_<mlir::arith::detail::UIToFPOpGenericAdaptorBase>(m, "UIToFPOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::UIToFPOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::UIToFPOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_UIToFPOpAdaptor = nb::class_<mlir::arith::UIToFPOpAdaptor>(m, "UIToFPOpAdaptor")
.def(nb::init<mlir::arith::UIToFPOp>(), "op"_a)
.def("verify", &mlir::arith::UIToFPOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_UIToFPOp = nb::class_<mlir::arith::UIToFPOp,  mlir::OpState>(m, "UIToFPOp")
.def_static("attribute_names", &mlir::arith::UIToFPOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::UIToFPOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::UIToFPOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::UIToFPOp::getODSOperands, "index"_a)
.def_prop_ro("in", &mlir::arith::UIToFPOp::getIn)
.def_prop_ro("in_mutable", &mlir::arith::UIToFPOp::getInMutable)
.def("get_ods_result_index_and_length", &mlir::arith::UIToFPOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::UIToFPOp::getODSResults, "index"_a)
.def_prop_ro("out", &mlir::arith::UIToFPOp::getOut)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type out, mlir::Value in){ return mlir::arith::UIToFPOp::build(odsBuilder, odsState, out, in); }, "ods_builder"_a, "ods_state"_a, "out"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value in){ return mlir::arith::UIToFPOp::build(odsBuilder, odsState, resultTypes, in); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "in"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::UIToFPOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::UIToFPOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::UIToFPOp::verifyInvariants)
.def("fold", &mlir::arith::UIToFPOp::fold, "adaptor"_a)
.def_static("are_cast_compatible", &mlir::arith::UIToFPOp::areCastCompatible, "inputs"_a, "outputs"_a)
.def_static("parse", &mlir::arith::UIToFPOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::UIToFPOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_UIToFPOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::UIToFPOp>>(m, "TypeIDResolver[arith::UIToFPOp]")
;

auto mlir_arith_detail_XOrIOpGenericAdaptorBase = nb::class_<mlir::arith::detail::XOrIOpGenericAdaptorBase>(m, "XOrIOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::XOrIOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::XOrIOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_XOrIOpAdaptor = nb::class_<mlir::arith::XOrIOpAdaptor>(m, "XOrIOpAdaptor")
.def(nb::init<mlir::arith::XOrIOp>(), "op"_a)
.def("verify", &mlir::arith::XOrIOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_XOrIOp = nb::class_<mlir::arith::XOrIOp,  mlir::OpState>(m, "XOrIOp")
.def_static("attribute_names", &mlir::arith::XOrIOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::XOrIOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::XOrIOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::XOrIOp::getODSOperands, "index"_a)
.def_prop_ro("lhs", &mlir::arith::XOrIOp::getLhs)
.def_prop_ro("rhs", &mlir::arith::XOrIOp::getRhs)
.def_prop_ro("lhs_mutable", &mlir::arith::XOrIOp::getLhsMutable)
.def_prop_ro("rhs_mutable", &mlir::arith::XOrIOp::getRhsMutable)
.def("get_ods_result_index_and_length", &mlir::arith::XOrIOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::XOrIOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::XOrIOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::XOrIOp::build(odsBuilder, odsState, result, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::XOrIOp::build(odsBuilder, odsState, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value lhs, mlir::Value rhs){ return mlir::arith::XOrIOp::build(odsBuilder, odsState, resultTypes, lhs, rhs); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "lhs"_a, "rhs"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::XOrIOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::XOrIOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::arith::XOrIOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::XOrIOp::verifyInvariants)
.def_static("get_canonicalization_patterns", &mlir::arith::XOrIOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::XOrIOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::XOrIOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges", &mlir::arith::XOrIOp::inferResultRanges, "arg_ranges"_a, "set_result_ranges"_a)
.def_static("parse", &mlir::arith::XOrIOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::arith::XOrIOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_XOrIOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::XOrIOp>>(m, "TypeIDResolver[arith::XOrIOp]")
;

auto mlir_arith_detail_SelectOpGenericAdaptorBase = nb::class_<mlir::arith::detail::SelectOpGenericAdaptorBase>(m, "SelectOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::arith::detail::SelectOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::arith::detail::SelectOpGenericAdaptorBase::getAttributes)
;

auto mlir_arith_SelectOpAdaptor = nb::class_<mlir::arith::SelectOpAdaptor>(m, "SelectOpAdaptor")
.def(nb::init<mlir::arith::SelectOp>(), "op"_a)
.def("verify", &mlir::arith::SelectOpAdaptor::verify, "loc"_a)
;

auto mlir_arith_SelectOp = nb::class_<mlir::arith::SelectOp,  mlir::OpState>(m, "SelectOp")
.def_static("attribute_names", &mlir::arith::SelectOp::getAttributeNames)
.def_static("operation_name", &mlir::arith::SelectOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::arith::SelectOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::arith::SelectOp::getODSOperands, "index"_a)
.def_prop_ro("condition", &mlir::arith::SelectOp::getCondition)
.def_prop_ro("true_value", &mlir::arith::SelectOp::getTrueValue)
.def_prop_ro("false_value", &mlir::arith::SelectOp::getFalseValue)
.def_prop_ro("condition_mutable", &mlir::arith::SelectOp::getConditionMutable)
.def_prop_ro("true_value_mutable", &mlir::arith::SelectOp::getTrueValueMutable)
.def_prop_ro("false_value_mutable", &mlir::arith::SelectOp::getFalseValueMutable)
.def("get_ods_result_index_and_length", &mlir::arith::SelectOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::arith::SelectOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::arith::SelectOp::getResult)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value condition, mlir::Value true_value, mlir::Value false_value){ return mlir::arith::SelectOp::build(odsBuilder, odsState, result, condition, true_value, false_value); }, "ods_builder"_a, "ods_state"_a, "result"_a, "condition"_a, "true_value"_a, "false_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value condition, mlir::Value true_value, mlir::Value false_value){ return mlir::arith::SelectOp::build(odsBuilder, odsState, condition, true_value, false_value); }, "ods_builder"_a, "ods_state"_a, "condition"_a, "true_value"_a, "false_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value condition, mlir::Value true_value, mlir::Value false_value){ return mlir::arith::SelectOp::build(odsBuilder, odsState, resultTypes, condition, true_value, false_value); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "condition"_a, "true_value"_a, "false_value"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::SelectOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::arith::SelectOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::arith::SelectOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::arith::SelectOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::arith::SelectOp::verifyInvariants)
.def("verify", &mlir::arith::SelectOp::verify)
.def_static("get_canonicalization_patterns", &mlir::arith::SelectOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::arith::SelectOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::arith::SelectOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("infer_result_ranges_from_optional", &mlir::arith::SelectOp::inferResultRangesFromOptional, "arg_ranges"_a, "set_result_ranges"_a)
.def("get_effects", &mlir::arith::SelectOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_arith_SelectOp__ = nb::class_<mlir::detail::TypeIDResolver<::mlir::arith::SelectOp>>(m, "TypeIDResolver[arith::SelectOp]")
;

}
