
#include "ir.h"
#include "llvm/Support/ThreadPool.h"
namespace nb = nanobind;
using namespace nb::literals;
void populateSCFModule(nanobind::module_ & m) {
using namespace mlir;
using namespace mlir::detail;
using namespace mlir::scf;

auto mlir_detail_DeviceMappingAttrInterfaceInterfaceTraits = nb::class_<mlir::detail::DeviceMappingAttrInterfaceInterfaceTraits>(m, "DeviceMappingAttrInterfaceInterfaceTraits")
;

auto mlir_detail_DeviceMappingAttrInterfaceInterfaceTraits_Concept = nb::class_<mlir::detail::DeviceMappingAttrInterfaceInterfaceTraits::Concept>(mlir_detail_DeviceMappingAttrInterfaceInterfaceTraits, "Concept")
;

auto mlir_DeviceMappingAttrInterface = nb::class_<mlir::DeviceMappingAttrInterface>(m, "DeviceMappingAttrInterface")
.def_prop_ro("mapping_id", &mlir::DeviceMappingAttrInterface::getMappingId)
.def("is_linear_mapping", &mlir::DeviceMappingAttrInterface::isLinearMapping)
.def_prop_ro("relative_index", &mlir::DeviceMappingAttrInterface::getRelativeIndex)
;

auto mlir_scf_SCFDialect = nb::class_<mlir::scf::SCFDialect, mlir::Dialect>(m, "SCFDialect")
.def_static("dialect_namespace", &mlir::scf::SCFDialect::getDialectNamespace)
.def_static("insert_into_registry", [](mlir::DialectRegistry &registry) { registry.insert<mlir::scf::SCFDialect>(); })
.def_static("load_into_context", [](mlir::MLIRContext &context) { return context.getOrLoadDialect<mlir::scf::SCFDialect>(); })
;

auto mlir_detail_TypeIDResolver___mlir_scf_SCFDialect__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::SCFDialect>>(m, "TypeIDResolver[scf::SCFDialect]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::SCFDialect>::resolveTypeID)
;

auto mlir_scf_detail_ConditionOpGenericAdaptorBase = nb::class_<mlir::scf::detail::ConditionOpGenericAdaptorBase>(m, "ConditionOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::ConditionOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::scf::detail::ConditionOpGenericAdaptorBase::getAttributes)
;

auto mlir_scf_ConditionOpAdaptor = nb::class_<mlir::scf::ConditionOpAdaptor>(m, "ConditionOpAdaptor")
.def(nb::init<mlir::scf::ConditionOp>(), "op"_a)
.def("verify", &mlir::scf::ConditionOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_ConditionOp = nb::class_<mlir::scf::ConditionOp,  mlir::OpState>(m, "ConditionOp")
.def_static("attribute_names", &mlir::scf::ConditionOp::getAttributeNames)
.def_static("operation_name", &mlir::scf::ConditionOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::ConditionOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::ConditionOp::getODSOperands, "index"_a)
.def_prop_ro("condition", &mlir::scf::ConditionOp::getCondition)
.def_prop_ro("args", &mlir::scf::ConditionOp::getArgs)
.def_prop_ro("condition_mutable", &mlir::scf::ConditionOp::getConditionMutable)
.def_prop_ro("args_mutable", &mlir::scf::ConditionOp::getArgsMutable)
.def("get_ods_result_index_and_length", &mlir::scf::ConditionOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::ConditionOp::getODSResults, "index"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value condition, mlir::ValueRange args){ return mlir::scf::ConditionOp::build(odsBuilder, odsState, condition, args); }, "ods_builder"_a, "ods_state"_a, "condition"_a, "args"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value condition, mlir::ValueRange args){ return mlir::scf::ConditionOp::build(odsBuilder, odsState, resultTypes, condition, args); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "condition"_a, "args"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::scf::ConditionOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::scf::ConditionOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::ConditionOp::verifyInvariants)
.def("get_mutable_successor_operands", &mlir::scf::ConditionOp::getMutableSuccessorOperands, "point"_a)
.def("get_successor_regions", &mlir::scf::ConditionOp::getSuccessorRegions, "operands"_a, "regions"_a)
.def_static("parse", &mlir::scf::ConditionOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::scf::ConditionOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_scf_ConditionOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::ConditionOp>>(m, "TypeIDResolver[scf::ConditionOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::ConditionOp>::resolveTypeID)
;

auto mlir_scf_detail_ExecuteRegionOpGenericAdaptorBase = nb::class_<mlir::scf::detail::ExecuteRegionOpGenericAdaptorBase>(m, "ExecuteRegionOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::ExecuteRegionOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::scf::detail::ExecuteRegionOpGenericAdaptorBase::getAttributes)
.def_prop_ro("region", &mlir::scf::detail::ExecuteRegionOpGenericAdaptorBase::getRegion)
.def_prop_ro("regions", &mlir::scf::detail::ExecuteRegionOpGenericAdaptorBase::getRegions)
;

auto mlir_scf_ExecuteRegionOpAdaptor = nb::class_<mlir::scf::ExecuteRegionOpAdaptor>(m, "ExecuteRegionOpAdaptor")
.def(nb::init<mlir::scf::ExecuteRegionOp>(), "op"_a)
.def("verify", &mlir::scf::ExecuteRegionOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_ExecuteRegionOp = nb::class_<mlir::scf::ExecuteRegionOp,  mlir::OpState>(m, "ExecuteRegionOp")
.def_static("attribute_names", &mlir::scf::ExecuteRegionOp::getAttributeNames)
.def_static("operation_name", &mlir::scf::ExecuteRegionOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::ExecuteRegionOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::ExecuteRegionOp::getODSOperands, "index"_a)
.def("get_ods_result_index_and_length", &mlir::scf::ExecuteRegionOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::ExecuteRegionOp::getODSResults, "index"_a)
.def_prop_ro("region", &mlir::scf::ExecuteRegionOp::getRegion)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultType0){ return mlir::scf::ExecuteRegionOp::build(odsBuilder, odsState, resultType0); }, "ods_builder"_a, "ods_state"_a, "result_type0"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::scf::ExecuteRegionOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::scf::ExecuteRegionOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::scf::ExecuteRegionOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::ExecuteRegionOp::verifyInvariants)
.def("verify", &mlir::scf::ExecuteRegionOp::verify)
.def_static("get_canonicalization_patterns", &mlir::scf::ExecuteRegionOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("get_successor_regions", &mlir::scf::ExecuteRegionOp::getSuccessorRegions, "point"_a, "regions"_a)
;

auto mlir_detail_TypeIDResolver___mlir_scf_ExecuteRegionOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::ExecuteRegionOp>>(m, "TypeIDResolver[scf::ExecuteRegionOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::ExecuteRegionOp>::resolveTypeID)
;

auto mlir_scf_detail_ForOpGenericAdaptorBase = nb::class_<mlir::scf::detail::ForOpGenericAdaptorBase>(m, "ForOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::ForOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::scf::detail::ForOpGenericAdaptorBase::getAttributes)
.def_prop_ro("region", &mlir::scf::detail::ForOpGenericAdaptorBase::getRegion)
.def_prop_ro("regions", &mlir::scf::detail::ForOpGenericAdaptorBase::getRegions)
;

auto mlir_scf_ForOpAdaptor = nb::class_<mlir::scf::ForOpAdaptor>(m, "ForOpAdaptor")
.def(nb::init<mlir::scf::ForOp>(), "op"_a)
.def("verify", &mlir::scf::ForOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_ForOp = nb::class_<mlir::scf::ForOp,  mlir::OpState>(m, "ForOp")
.def_static("attribute_names", &mlir::scf::ForOp::getAttributeNames)
.def_static("operation_name", &mlir::scf::ForOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::ForOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::ForOp::getODSOperands, "index"_a)
.def_prop_ro("lower_bound", &mlir::scf::ForOp::getLowerBound)
.def_prop_ro("upper_bound", &mlir::scf::ForOp::getUpperBound)
.def_prop_ro("step", &mlir::scf::ForOp::getStep)
.def_prop_ro("init_args", &mlir::scf::ForOp::getInitArgs)
.def_prop_ro("lower_bound_mutable", &mlir::scf::ForOp::getLowerBoundMutable)
.def_prop_ro("upper_bound_mutable", &mlir::scf::ForOp::getUpperBoundMutable)
.def_prop_ro("step_mutable", &mlir::scf::ForOp::getStepMutable)
.def_prop_ro("init_args_mutable", &mlir::scf::ForOp::getInitArgsMutable)
.def("get_ods_result_index_and_length", &mlir::scf::ForOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::ForOp::getODSResults, "index"_a)
.def_prop_ro("results", &mlir::scf::ForOp::getResults)
.def_prop_ro("region", &mlir::scf::ForOp::getRegion)
.def_static("build", &mlir::scf::ForOp::build, "ods_builder"_a, "ods_state"_a, "lower_bound"_a, "upper_bound"_a, "step"_a, "init_args"_a, "ods_arg4"_a)
.def_static("parse", &mlir::scf::ForOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::scf::ForOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::ForOp::verifyInvariants)
.def("verify", &mlir::scf::ForOp::verify)
.def("verify_regions", &mlir::scf::ForOp::verifyRegions)
.def_static("get_canonicalization_patterns", &mlir::scf::ForOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def_prop_ro("loop_regions", &mlir::scf::ForOp::getLoopRegions)
.def("promote_if_single_iteration", &mlir::scf::ForOp::promoteIfSingleIteration, "rewriter"_a)
.def_prop_ro("loop_induction_vars", &mlir::scf::ForOp::getLoopInductionVars)
.def_prop_ro("loop_lower_bounds", &mlir::scf::ForOp::getLoopLowerBounds)
.def_prop_ro("loop_steps", &mlir::scf::ForOp::getLoopSteps)
.def_prop_ro("loop_upper_bounds", &mlir::scf::ForOp::getLoopUpperBounds)
.def_prop_ro("inits_mutable", &mlir::scf::ForOp::getInitsMutable)
.def_prop_ro("region_iter_args", &mlir::scf::ForOp::getRegionIterArgs)
.def_prop_ro("yielded_values_mutable", &mlir::scf::ForOp::getYieldedValuesMutable)
.def_prop_ro("loop_results", &mlir::scf::ForOp::getLoopResults)
.def("replace_with_additional_yields", &mlir::scf::ForOp::replaceWithAdditionalYields, "rewriter"_a, "new_init_operands"_a, "replace_init_operand_uses_in_loop"_a, "new_yield_values_fn"_a)
.def("get_entry_successor_operands", &mlir::scf::ForOp::getEntrySuccessorOperands, "point"_a)
.def("get_successor_regions", &mlir::scf::ForOp::getSuccessorRegions, "point"_a, "regions"_a)
.def_prop_ro("induction_var", &mlir::scf::ForOp::getInductionVar)
.def("get_region_iter_arg", &mlir::scf::ForOp::getRegionIterArg, "index"_a)
.def("set_lower_bound", &mlir::scf::ForOp::setLowerBound, "bound"_a)
.def("set_upper_bound", &mlir::scf::ForOp::setUpperBound, "bound"_a)
.def("set_step", &mlir::scf::ForOp::setStep, "step"_a)
.def_prop_ro("num_induction_vars", &mlir::scf::ForOp::getNumInductionVars)
.def_prop_ro("num_region_iter_args", &mlir::scf::ForOp::getNumRegionIterArgs)
.def_prop_ro("num_control_operands", &mlir::scf::ForOp::getNumControlOperands)
.def_prop_ro("constant_step", &mlir::scf::ForOp::getConstantStep)
.def_prop_ro("speculatability", &mlir::scf::ForOp::getSpeculatability)
;

auto mlir_detail_TypeIDResolver___mlir_scf_ForOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::ForOp>>(m, "TypeIDResolver[scf::ForOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::ForOp>::resolveTypeID)
;

auto mlir_scf_detail_ForallOpGenericAdaptorBase = nb::class_<mlir::scf::detail::ForallOpGenericAdaptorBase>(m, "ForallOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::scf::detail::ForallOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::scf::ForallOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::ForallOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::scf::detail::ForallOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::scf::detail::ForallOpGenericAdaptorBase::getAttributes)
.def_prop_ro("static_lower_bound_attr", &mlir::scf::detail::ForallOpGenericAdaptorBase::getStaticLowerBoundAttr)
.def_prop_ro("static_lower_bound", &mlir::scf::detail::ForallOpGenericAdaptorBase::getStaticLowerBound)
.def_prop_ro("static_upper_bound_attr", &mlir::scf::detail::ForallOpGenericAdaptorBase::getStaticUpperBoundAttr)
.def_prop_ro("static_upper_bound", &mlir::scf::detail::ForallOpGenericAdaptorBase::getStaticUpperBound)
.def_prop_ro("static_step_attr", &mlir::scf::detail::ForallOpGenericAdaptorBase::getStaticStepAttr)
.def_prop_ro("static_step", &mlir::scf::detail::ForallOpGenericAdaptorBase::getStaticStep)
.def_prop_ro("mapping_attr", &mlir::scf::detail::ForallOpGenericAdaptorBase::getMappingAttr)
.def_prop_ro("mapping", &mlir::scf::detail::ForallOpGenericAdaptorBase::getMapping)
.def_prop_ro("region", &mlir::scf::detail::ForallOpGenericAdaptorBase::getRegion)
.def_prop_ro("regions", &mlir::scf::detail::ForallOpGenericAdaptorBase::getRegions)
;

auto mlir_scf_detail_ForallOpGenericAdaptorBase_Properties = nb::class_<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties>(mlir_scf_detail_ForallOpGenericAdaptorBase, "Properties")
.def_prop_ro("mapping", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::getMapping)
.def("set_mapping", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::setMapping, "prop_value"_a)
.def_prop_ro("static_lower_bound", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::getStaticLowerBound)
.def("set_static_lower_bound", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::setStaticLowerBound, "prop_value"_a)
.def_prop_ro("static_step", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::getStaticStep)
.def("set_static_step", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::setStaticStep, "prop_value"_a)
.def_prop_ro("static_upper_bound", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::getStaticUpperBound)
.def("set_static_upper_bound", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::setStaticUpperBound, "prop_value"_a)
.def_prop_ro("operand_segment_sizes", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::getOperandSegmentSizes)
.def("set_operand_segment_sizes", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::setOperandSegmentSizes, "prop_value"_a)
.def("__eq__", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::scf::detail::ForallOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_scf_ForallOpAdaptor = nb::class_<mlir::scf::ForallOpAdaptor>(m, "ForallOpAdaptor")
.def(nb::init<mlir::scf::ForallOp>(), "op"_a)
.def("verify", &mlir::scf::ForallOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_ForallOp = nb::class_<mlir::scf::ForallOp,  mlir::OpState>(m, "ForallOp")
.def_static("attribute_names", &mlir::scf::ForallOp::getAttributeNames)
.def_prop_ro("mapping_attr_name", [](mlir::scf::ForallOp& self){ return self.getMappingAttrName(); })
.def_static("get_mapping_attr_name", [](mlir::OperationName name){ return mlir::scf::ForallOp::getMappingAttrName(name); }, "name"_a)
.def_prop_ro("static_lower_bound_attr_name", [](mlir::scf::ForallOp& self){ return self.getStaticLowerBoundAttrName(); })
.def_static("get_static_lower_bound_attr_name", [](mlir::OperationName name){ return mlir::scf::ForallOp::getStaticLowerBoundAttrName(name); }, "name"_a)
.def_prop_ro("static_step_attr_name", [](mlir::scf::ForallOp& self){ return self.getStaticStepAttrName(); })
.def_static("get_static_step_attr_name", [](mlir::OperationName name){ return mlir::scf::ForallOp::getStaticStepAttrName(name); }, "name"_a)
.def_prop_ro("static_upper_bound_attr_name", [](mlir::scf::ForallOp& self){ return self.getStaticUpperBoundAttrName(); })
.def_static("get_static_upper_bound_attr_name", [](mlir::OperationName name){ return mlir::scf::ForallOp::getStaticUpperBoundAttrName(name); }, "name"_a)
.def_prop_ro("operand_segment_sizes_attr_name", [](mlir::scf::ForallOp& self){ return self.getOperandSegmentSizesAttrName(); })
.def_static("get_operand_segment_sizes_attr_name", [](mlir::OperationName name){ return mlir::scf::ForallOp::getOperandSegmentSizesAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::scf::ForallOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::ForallOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::ForallOp::getODSOperands, "index"_a)
.def_prop_ro("dynamic_lower_bound", &mlir::scf::ForallOp::getDynamicLowerBound)
.def_prop_ro("dynamic_upper_bound", &mlir::scf::ForallOp::getDynamicUpperBound)
.def_prop_ro("dynamic_step", &mlir::scf::ForallOp::getDynamicStep)
.def_prop_ro("outputs", &mlir::scf::ForallOp::getOutputs)
.def_prop_ro("dynamic_lower_bound_mutable", &mlir::scf::ForallOp::getDynamicLowerBoundMutable)
.def_prop_ro("dynamic_upper_bound_mutable", &mlir::scf::ForallOp::getDynamicUpperBoundMutable)
.def_prop_ro("dynamic_step_mutable", &mlir::scf::ForallOp::getDynamicStepMutable)
.def_prop_ro("outputs_mutable", &mlir::scf::ForallOp::getOutputsMutable)
.def("get_ods_result_index_and_length", &mlir::scf::ForallOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::ForallOp::getODSResults, "index"_a)
.def_prop_ro("results", &mlir::scf::ForallOp::getResults)
.def_prop_ro("region", &mlir::scf::ForallOp::getRegion)
.def_static("set_properties_from_attr", &mlir::scf::ForallOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::scf::ForallOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::scf::ForallOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::scf::ForallOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::scf::ForallOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::scf::ForallOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::scf::ForallOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::scf::ForallOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::scf::ForallOp::writeProperties, "writer"_a)
.def_prop_ro("static_lower_bound_attr", &mlir::scf::ForallOp::getStaticLowerBoundAttr)
.def_prop_ro("static_lower_bound", &mlir::scf::ForallOp::getStaticLowerBound)
.def_prop_ro("static_upper_bound_attr", &mlir::scf::ForallOp::getStaticUpperBoundAttr)
.def_prop_ro("static_upper_bound", &mlir::scf::ForallOp::getStaticUpperBound)
.def_prop_ro("static_step_attr", &mlir::scf::ForallOp::getStaticStepAttr)
.def_prop_ro("static_step", &mlir::scf::ForallOp::getStaticStep)
.def_prop_ro("mapping_attr", &mlir::scf::ForallOp::getMappingAttr)
.def_prop_ro("mapping", &mlir::scf::ForallOp::getMapping)
.def("set_static_lower_bound_attr", &mlir::scf::ForallOp::setStaticLowerBoundAttr, "attr"_a)
.def("set_static_lower_bound", &mlir::scf::ForallOp::setStaticLowerBound, "attr_value"_a)
.def("set_static_upper_bound_attr", &mlir::scf::ForallOp::setStaticUpperBoundAttr, "attr"_a)
.def("set_static_upper_bound", &mlir::scf::ForallOp::setStaticUpperBound, "attr_value"_a)
.def("set_static_step_attr", &mlir::scf::ForallOp::setStaticStepAttr, "attr"_a)
.def("set_static_step", &mlir::scf::ForallOp::setStaticStep, "attr_value"_a)
.def("set_mapping_attr", &mlir::scf::ForallOp::setMappingAttr, "attr"_a)
.def("remove_mapping_attr", &mlir::scf::ForallOp::removeMappingAttr)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, llvm::ArrayRef<mlir::OpFoldResult> lbs, llvm::ArrayRef<mlir::OpFoldResult> ubs, llvm::ArrayRef<mlir::OpFoldResult> steps, mlir::ValueRange outputs, std::optional<mlir::ArrayAttr> mapping, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location, mlir::ValueRange)> bodyBuilderFn){ return mlir::scf::ForallOp::build(odsBuilder, odsState, lbs, ubs, steps, outputs, mapping, bodyBuilderFn); }, "ods_builder"_a, "ods_state"_a, "lbs"_a, "ubs"_a, "steps"_a, "outputs"_a, "mapping"_a, "body_builder_fn"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, llvm::ArrayRef<mlir::OpFoldResult> ubs, mlir::ValueRange outputs, std::optional<mlir::ArrayAttr> mapping, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location, mlir::ValueRange)> bodyBuilderFn){ return mlir::scf::ForallOp::build(odsBuilder, odsState, ubs, outputs, mapping, bodyBuilderFn); }, "ods_builder"_a, "ods_state"_a, "ubs"_a, "outputs"_a, "mapping"_a, "body_builder_fn"_a)
.def_static("parse", &mlir::scf::ForallOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::scf::ForallOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::ForallOp::verifyInvariants)
.def("verify", &mlir::scf::ForallOp::verify)
.def_static("get_canonicalization_patterns", &mlir::scf::ForallOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def_prop_ro("loop_regions", &mlir::scf::ForallOp::getLoopRegions)
.def("promote_if_single_iteration", &mlir::scf::ForallOp::promoteIfSingleIteration, "rewriter"_a)
.def_prop_ro("loop_induction_vars", &mlir::scf::ForallOp::getLoopInductionVars)
.def_prop_ro("loop_lower_bounds", &mlir::scf::ForallOp::getLoopLowerBounds)
.def_prop_ro("loop_steps", &mlir::scf::ForallOp::getLoopSteps)
.def_prop_ro("loop_upper_bounds", &mlir::scf::ForallOp::getLoopUpperBounds)
.def_prop_ro("inits_mutable", &mlir::scf::ForallOp::getInitsMutable)
.def_prop_ro("region_iter_args", &mlir::scf::ForallOp::getRegionIterArgs)
.def("get_successor_regions", &mlir::scf::ForallOp::getSuccessorRegions, "point"_a, "regions"_a)
.def_prop_ro("induction_vars", &mlir::scf::ForallOp::getInductionVars)
.def_prop_ro("mixed_lower_bound", &mlir::scf::ForallOp::getMixedLowerBound)
.def_prop_ro("mixed_upper_bound", &mlir::scf::ForallOp::getMixedUpperBound)
.def_prop_ro("mixed_step", &mlir::scf::ForallOp::getMixedStep)
.def("get_lower_bound", &mlir::scf::ForallOp::getLowerBound, "b"_a)
.def("get_upper_bound", &mlir::scf::ForallOp::getUpperBound, "b"_a)
.def("get_step", &mlir::scf::ForallOp::getStep, "b"_a)
.def_prop_ro("rank", &mlir::scf::ForallOp::getRank)
.def_prop_ro("num_control_operands", &mlir::scf::ForallOp::getNumControlOperands)
.def_prop_ro("num_dynamic_control_operands", &mlir::scf::ForallOp::getNumDynamicControlOperands)
.def("get_tied_op_result", &mlir::scf::ForallOp::getTiedOpResult, "op_operand"_a)
.def("get_tied_op_operand", [](mlir::scf::ForallOp& self, mlir::BlockArgument bbArg){ return self.getTiedOpOperand(bbArg); }, "bb_arg"_a, nb::rv_policy::reference_internal)
.def("get_tied_op_operand", [](mlir::scf::ForallOp& self, mlir::OpResult opResult){ return self.getTiedOpOperand(opResult); }, "op_result"_a, nb::rv_policy::reference_internal)
.def("get_tied_block_argument", &mlir::scf::ForallOp::getTiedBlockArgument, "op_operand"_a)
.def("get_induction_var", &mlir::scf::ForallOp::getInductionVar, "idx"_a)
.def_prop_ro("region_out_args", &mlir::scf::ForallOp::getRegionOutArgs)
.def("is_normalized", &mlir::scf::ForallOp::isNormalized)
.def_static("ensure_terminator", &mlir::scf::ForallOp::ensureTerminator, "region"_a, "builder"_a, "loc"_a)
.def_prop_ro("terminator", &mlir::scf::ForallOp::getTerminator)
.def_prop_ro("dps_inits_mutable", &mlir::scf::ForallOp::getDpsInitsMutable)
.def("get_combining_ops", &mlir::scf::ForallOp::getCombiningOps, "bb_arg"_a)
;

auto mlir_detail_TypeIDResolver___mlir_scf_ForallOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::ForallOp>>(m, "TypeIDResolver[scf::ForallOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::ForallOp>::resolveTypeID)
;

auto mlir_scf_detail_IfOpGenericAdaptorBase = nb::class_<mlir::scf::detail::IfOpGenericAdaptorBase>(m, "IfOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::scf::detail::IfOpGenericAdaptorBase::getAttributes)
.def_prop_ro("then_region", &mlir::scf::detail::IfOpGenericAdaptorBase::getThenRegion)
.def_prop_ro("else_region", &mlir::scf::detail::IfOpGenericAdaptorBase::getElseRegion)
.def_prop_ro("regions", &mlir::scf::detail::IfOpGenericAdaptorBase::getRegions)
;

auto mlir_scf_IfOpAdaptor = nb::class_<mlir::scf::IfOpAdaptor>(m, "IfOpAdaptor")
.def(nb::init<mlir::scf::IfOp>(), "op"_a)
.def("verify", &mlir::scf::IfOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_IfOp = nb::class_<mlir::scf::IfOp,  mlir::OpState>(m, "IfOp")
.def_static("attribute_names", &mlir::scf::IfOp::getAttributeNames)
.def_static("operation_name", &mlir::scf::IfOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::IfOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::IfOp::getODSOperands, "index"_a)
.def_prop_ro("condition", &mlir::scf::IfOp::getCondition)
.def_prop_ro("condition_mutable", &mlir::scf::IfOp::getConditionMutable)
.def("get_ods_result_index_and_length", &mlir::scf::IfOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::IfOp::getODSResults, "index"_a)
.def_prop_ro("results", &mlir::scf::IfOp::getResults)
.def_prop_ro("then_region", &mlir::scf::IfOp::getThenRegion)
.def_prop_ro("else_region", &mlir::scf::IfOp::getElseRegion)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value cond){ return mlir::scf::IfOp::build(odsBuilder, odsState, resultTypes, cond); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "cond"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value cond, bool addThenBlock, bool addElseBlock){ return mlir::scf::IfOp::build(odsBuilder, odsState, resultTypes, cond, addThenBlock, addElseBlock); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "cond"_a, "add_then_block"_a, "add_else_block"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value cond, bool withElseRegion){ return mlir::scf::IfOp::build(odsBuilder, odsState, cond, withElseRegion); }, "ods_builder"_a, "ods_state"_a, "cond"_a, "with_else_region"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value cond, bool withElseRegion){ return mlir::scf::IfOp::build(odsBuilder, odsState, resultTypes, cond, withElseRegion); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "cond"_a, "with_else_region"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value cond, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location)> thenBuilder, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location)> elseBuilder){ return mlir::scf::IfOp::build(odsBuilder, odsState, cond, thenBuilder, elseBuilder); }, "ods_builder"_a, "ods_state"_a, "cond"_a, "then_builder"_a, "else_builder"_a)
.def_static("parse", &mlir::scf::IfOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::scf::IfOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::IfOp::verifyInvariants)
.def("verify", &mlir::scf::IfOp::verify)
.def_static("get_canonicalization_patterns", &mlir::scf::IfOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::scf::IfOp::fold, "adaptor"_a, "results"_a)
.def("get_entry_successor_regions", &mlir::scf::IfOp::getEntrySuccessorRegions, "operands"_a, "regions"_a)
.def("get_successor_regions", &mlir::scf::IfOp::getSuccessorRegions, "point"_a, "regions"_a)
.def("get_region_invocation_bounds", &mlir::scf::IfOp::getRegionInvocationBounds, "operands"_a, "invocation_bounds"_a)
.def_static("infer_return_types", [](mlir::MLIRContext * context, std::optional<mlir::Location> location, mlir::ValueRange operands, mlir::DictionaryAttr attributes, mlir::OpaqueProperties properties, mlir::RegionRange regions, llvm::SmallVectorImpl<mlir::Type> & inferredReturnTypes){ return mlir::scf::IfOp::inferReturnTypes(context, location, operands, attributes, properties, regions, inferredReturnTypes); }, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("infer_return_types", [](mlir::MLIRContext * context, std::optional<mlir::Location> location, mlir::scf::IfOp::Adaptor adaptor, llvm::SmallVectorImpl<mlir::Type> & inferredReturnTypes){ return mlir::scf::IfOp::inferReturnTypes(context, location, adaptor, inferredReturnTypes); }, "context"_a, "location"_a, "adaptor"_a, "inferred_return_types"_a)
.def("get_then_body_builder", &mlir::scf::IfOp::getThenBodyBuilder, "listener"_a)
.def("get_else_body_builder", &mlir::scf::IfOp::getElseBodyBuilder, "listener"_a)
.def("then_block", &mlir::scf::IfOp::thenBlock, nb::rv_policy::reference_internal)
.def("then_yield", &mlir::scf::IfOp::thenYield)
.def("else_block", &mlir::scf::IfOp::elseBlock, nb::rv_policy::reference_internal)
.def("else_yield", &mlir::scf::IfOp::elseYield)
;

auto mlir_detail_TypeIDResolver___mlir_scf_IfOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::IfOp>>(m, "TypeIDResolver[scf::IfOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::IfOp>::resolveTypeID)
;

auto mlir_scf_detail_InParallelOpGenericAdaptorBase = nb::class_<mlir::scf::detail::InParallelOpGenericAdaptorBase>(m, "InParallelOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::InParallelOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::scf::detail::InParallelOpGenericAdaptorBase::getAttributes)
.def_prop_ro("region", &mlir::scf::detail::InParallelOpGenericAdaptorBase::getRegion)
.def_prop_ro("regions", &mlir::scf::detail::InParallelOpGenericAdaptorBase::getRegions)
;

auto mlir_scf_InParallelOpAdaptor = nb::class_<mlir::scf::InParallelOpAdaptor>(m, "InParallelOpAdaptor")
.def(nb::init<mlir::scf::InParallelOp>(), "op"_a)
.def("verify", &mlir::scf::InParallelOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_InParallelOp = nb::class_<mlir::scf::InParallelOp,  mlir::OpState>(m, "InParallelOp")
.def_static("attribute_names", &mlir::scf::InParallelOp::getAttributeNames)
.def_static("operation_name", &mlir::scf::InParallelOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::InParallelOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::InParallelOp::getODSOperands, "index"_a)
.def("get_ods_result_index_and_length", &mlir::scf::InParallelOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::InParallelOp::getODSResults, "index"_a)
.def_prop_ro("region", &mlir::scf::InParallelOp::getRegion)
.def_static("build", &mlir::scf::InParallelOp::build, "ods_builder"_a, "ods_state"_a)
.def_static("parse", &mlir::scf::InParallelOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::scf::InParallelOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::InParallelOp::verifyInvariants)
.def("verify", &mlir::scf::InParallelOp::verify)
.def("get_effects", &mlir::scf::InParallelOp::getEffects, "effects"_a)
.def_prop_ro("dests", &mlir::scf::InParallelOp::getDests)
.def_prop_ro("yielding_ops", &mlir::scf::InParallelOp::getYieldingOps)
.def("get_parent_result", &mlir::scf::InParallelOp::getParentResult, "idx"_a)
;

auto mlir_detail_TypeIDResolver___mlir_scf_InParallelOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::InParallelOp>>(m, "TypeIDResolver[scf::InParallelOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::InParallelOp>::resolveTypeID)
;

auto mlir_scf_detail_IndexSwitchOpGenericAdaptorBase = nb::class_<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase>(m, "IndexSwitchOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::scf::IndexSwitchOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::getAttributes)
.def_prop_ro("cases_attr", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::getCasesAttr)
.def_prop_ro("cases", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::getCases)
.def_prop_ro("default_region", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::getDefaultRegion)
.def_prop_ro("case_regions", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::getCaseRegions)
.def_prop_ro("regions", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::getRegions)
;

auto mlir_scf_detail_IndexSwitchOpGenericAdaptorBase_Properties = nb::class_<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties>(mlir_scf_detail_IndexSwitchOpGenericAdaptorBase, "Properties")
.def_prop_ro("cases", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties::getCases)
.def("set_cases", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties::setCases, "prop_value"_a)
.def("__eq__", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_scf_IndexSwitchOpAdaptor = nb::class_<mlir::scf::IndexSwitchOpAdaptor>(m, "IndexSwitchOpAdaptor")
.def(nb::init<mlir::scf::IndexSwitchOp>(), "op"_a)
.def("verify", &mlir::scf::IndexSwitchOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_IndexSwitchOp = nb::class_<mlir::scf::IndexSwitchOp,  mlir::OpState>(m, "IndexSwitchOp")
.def_static("attribute_names", &mlir::scf::IndexSwitchOp::getAttributeNames)
.def_prop_ro("cases_attr_name", [](mlir::scf::IndexSwitchOp& self){ return self.getCasesAttrName(); })
.def_static("get_cases_attr_name", [](mlir::OperationName name){ return mlir::scf::IndexSwitchOp::getCasesAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::scf::IndexSwitchOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::IndexSwitchOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::IndexSwitchOp::getODSOperands, "index"_a)
.def_prop_ro("arg", &mlir::scf::IndexSwitchOp::getArg)
.def_prop_ro("arg_mutable", &mlir::scf::IndexSwitchOp::getArgMutable)
.def("get_ods_result_index_and_length", &mlir::scf::IndexSwitchOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::IndexSwitchOp::getODSResults, "index"_a)
.def_prop_ro("results", &mlir::scf::IndexSwitchOp::getResults)
.def_prop_ro("default_region", &mlir::scf::IndexSwitchOp::getDefaultRegion)
.def_prop_ro("case_regions", &mlir::scf::IndexSwitchOp::getCaseRegions)
.def_static("set_properties_from_attr", &mlir::scf::IndexSwitchOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::scf::IndexSwitchOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::scf::IndexSwitchOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::scf::IndexSwitchOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::scf::IndexSwitchOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::scf::IndexSwitchOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::scf::IndexSwitchOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::scf::IndexSwitchOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::scf::IndexSwitchOp::writeProperties, "writer"_a)
.def_prop_ro("cases_attr", &mlir::scf::IndexSwitchOp::getCasesAttr)
.def_prop_ro("cases", &mlir::scf::IndexSwitchOp::getCases)
.def("set_cases_attr", &mlir::scf::IndexSwitchOp::setCasesAttr, "attr"_a)
.def("set_cases", &mlir::scf::IndexSwitchOp::setCases, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange results, mlir::Value arg, mlir::detail::DenseArrayAttrImpl<int64_t> cases, unsigned int caseRegionsCount){ return mlir::scf::IndexSwitchOp::build(odsBuilder, odsState, results, arg, cases, caseRegionsCount); }, "ods_builder"_a, "ods_state"_a, "results"_a, "arg"_a, "cases"_a, "case_regions_count"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange results, mlir::Value arg, ::llvm::ArrayRef<int64_t> cases, unsigned int caseRegionsCount){ return mlir::scf::IndexSwitchOp::build(odsBuilder, odsState, results, arg, cases, caseRegionsCount); }, "ods_builder"_a, "ods_state"_a, "results"_a, "arg"_a, "cases"_a, "case_regions_count"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes, unsigned int numRegions){ return mlir::scf::IndexSwitchOp::build(_, odsState, resultTypes, operands, attributes, numRegions); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a, "num_regions"_a)
.def("verify_invariants_impl", &mlir::scf::IndexSwitchOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::IndexSwitchOp::verifyInvariants)
.def("verify", &mlir::scf::IndexSwitchOp::verify)
.def_static("get_canonicalization_patterns", &mlir::scf::IndexSwitchOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("get_entry_successor_regions", &mlir::scf::IndexSwitchOp::getEntrySuccessorRegions, "operands"_a, "regions"_a)
.def("get_successor_regions", &mlir::scf::IndexSwitchOp::getSuccessorRegions, "point"_a, "regions"_a)
.def("get_region_invocation_bounds", &mlir::scf::IndexSwitchOp::getRegionInvocationBounds, "operands"_a, "invocation_bounds"_a)
.def_static("parse", &mlir::scf::IndexSwitchOp::parse, "parser"_a, "result"_a)
.def_prop_ro("num_cases", &mlir::scf::IndexSwitchOp::getNumCases)
.def_prop_ro("default_block", &mlir::scf::IndexSwitchOp::getDefaultBlock)
.def("get_case_block", &mlir::scf::IndexSwitchOp::getCaseBlock, "idx"_a, nb::rv_policy::reference_internal)
;

auto mlir_detail_TypeIDResolver___mlir_scf_IndexSwitchOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::IndexSwitchOp>>(m, "TypeIDResolver[scf::IndexSwitchOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::IndexSwitchOp>::resolveTypeID)
;

auto mlir_scf_detail_ParallelOpGenericAdaptorBase = nb::class_<mlir::scf::detail::ParallelOpGenericAdaptorBase>(m, "ParallelOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::scf::ParallelOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::ParallelOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::scf::detail::ParallelOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::scf::detail::ParallelOpGenericAdaptorBase::getAttributes)
.def_prop_ro("region", &mlir::scf::detail::ParallelOpGenericAdaptorBase::getRegion)
.def_prop_ro("regions", &mlir::scf::detail::ParallelOpGenericAdaptorBase::getRegions)
;

auto mlir_scf_detail_ParallelOpGenericAdaptorBase_Properties = nb::class_<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties>(mlir_scf_detail_ParallelOpGenericAdaptorBase, "Properties")
.def_prop_ro("operand_segment_sizes", &mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties::getOperandSegmentSizes)
.def("set_operand_segment_sizes", &mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties::setOperandSegmentSizes, "prop_value"_a)
.def("__eq__", &mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_scf_ParallelOpAdaptor = nb::class_<mlir::scf::ParallelOpAdaptor>(m, "ParallelOpAdaptor")
.def(nb::init<mlir::scf::ParallelOp>(), "op"_a)
.def("verify", &mlir::scf::ParallelOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_ParallelOp = nb::class_<mlir::scf::ParallelOp,  mlir::OpState>(m, "ParallelOp")
.def_static("attribute_names", &mlir::scf::ParallelOp::getAttributeNames)
.def_prop_ro("operand_segment_sizes_attr_name", [](mlir::scf::ParallelOp& self){ return self.getOperandSegmentSizesAttrName(); })
.def_static("get_operand_segment_sizes_attr_name", [](mlir::OperationName name){ return mlir::scf::ParallelOp::getOperandSegmentSizesAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::scf::ParallelOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::ParallelOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::ParallelOp::getODSOperands, "index"_a)
.def_prop_ro("lower_bound", &mlir::scf::ParallelOp::getLowerBound)
.def_prop_ro("upper_bound", &mlir::scf::ParallelOp::getUpperBound)
.def_prop_ro("step", &mlir::scf::ParallelOp::getStep)
.def_prop_ro("init_vals", &mlir::scf::ParallelOp::getInitVals)
.def_prop_ro("lower_bound_mutable", &mlir::scf::ParallelOp::getLowerBoundMutable)
.def_prop_ro("upper_bound_mutable", &mlir::scf::ParallelOp::getUpperBoundMutable)
.def_prop_ro("step_mutable", &mlir::scf::ParallelOp::getStepMutable)
.def_prop_ro("init_vals_mutable", &mlir::scf::ParallelOp::getInitValsMutable)
.def("get_ods_result_index_and_length", &mlir::scf::ParallelOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::ParallelOp::getODSResults, "index"_a)
.def_prop_ro("results", &mlir::scf::ParallelOp::getResults)
.def_prop_ro("region", &mlir::scf::ParallelOp::getRegion)
.def_static("set_properties_from_attr", &mlir::scf::ParallelOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::scf::ParallelOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::scf::ParallelOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::scf::ParallelOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::scf::ParallelOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::scf::ParallelOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::scf::ParallelOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::scf::ParallelOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::scf::ParallelOp::writeProperties, "writer"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange lowerBounds, mlir::ValueRange upperBounds, mlir::ValueRange steps, mlir::ValueRange initVals, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location, mlir::ValueRange, mlir::ValueRange)> bodyBuilderFn){ return mlir::scf::ParallelOp::build(odsBuilder, odsState, lowerBounds, upperBounds, steps, initVals, bodyBuilderFn); }, "ods_builder"_a, "ods_state"_a, "lower_bounds"_a, "upper_bounds"_a, "steps"_a, "init_vals"_a, "body_builder_fn"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange lowerBounds, mlir::ValueRange upperBounds, mlir::ValueRange steps, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location, mlir::ValueRange)> bodyBuilderFn){ return mlir::scf::ParallelOp::build(odsBuilder, odsState, lowerBounds, upperBounds, steps, bodyBuilderFn); }, "ods_builder"_a, "ods_state"_a, "lower_bounds"_a, "upper_bounds"_a, "steps"_a, "body_builder_fn"_a)
.def_static("parse", &mlir::scf::ParallelOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::scf::ParallelOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::ParallelOp::verifyInvariants)
.def("verify", &mlir::scf::ParallelOp::verify)
.def_static("get_canonicalization_patterns", &mlir::scf::ParallelOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def_prop_ro("loop_regions", &mlir::scf::ParallelOp::getLoopRegions)
.def_prop_ro("loop_induction_vars", &mlir::scf::ParallelOp::getLoopInductionVars)
.def_prop_ro("loop_lower_bounds", &mlir::scf::ParallelOp::getLoopLowerBounds)
.def_prop_ro("loop_steps", &mlir::scf::ParallelOp::getLoopSteps)
.def_prop_ro("loop_upper_bounds", &mlir::scf::ParallelOp::getLoopUpperBounds)
.def("get_successor_regions", &mlir::scf::ParallelOp::getSuccessorRegions, "point"_a, "regions"_a)
.def_prop_ro("induction_vars", &mlir::scf::ParallelOp::getInductionVars)
.def_prop_ro("num_loops", &mlir::scf::ParallelOp::getNumLoops)
.def_prop_ro("num_reductions", &mlir::scf::ParallelOp::getNumReductions)
;

auto mlir_detail_TypeIDResolver___mlir_scf_ParallelOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::ParallelOp>>(m, "TypeIDResolver[scf::ParallelOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::ParallelOp>::resolveTypeID)
;

auto mlir_scf_detail_ReduceOpGenericAdaptorBase = nb::class_<mlir::scf::detail::ReduceOpGenericAdaptorBase>(m, "ReduceOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::ReduceOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::scf::detail::ReduceOpGenericAdaptorBase::getAttributes)
.def_prop_ro("reductions", &mlir::scf::detail::ReduceOpGenericAdaptorBase::getReductions)
.def_prop_ro("regions", &mlir::scf::detail::ReduceOpGenericAdaptorBase::getRegions)
;

auto mlir_scf_ReduceOpAdaptor = nb::class_<mlir::scf::ReduceOpAdaptor>(m, "ReduceOpAdaptor")
.def(nb::init<mlir::scf::ReduceOp>(), "op"_a)
.def("verify", &mlir::scf::ReduceOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_ReduceOp = nb::class_<mlir::scf::ReduceOp,  mlir::OpState>(m, "ReduceOp")
.def_static("attribute_names", &mlir::scf::ReduceOp::getAttributeNames)
.def_static("operation_name", &mlir::scf::ReduceOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::ReduceOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::ReduceOp::getODSOperands, "index"_a)
.def_prop_ro("operands", &mlir::scf::ReduceOp::getOperands)
.def_prop_ro("operands_mutable", &mlir::scf::ReduceOp::getOperandsMutable)
.def("get_ods_result_index_and_length", &mlir::scf::ReduceOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::ReduceOp::getODSResults, "index"_a)
.def_prop_ro("reductions", &mlir::scf::ReduceOp::getReductions)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands){ return mlir::scf::ReduceOp::build(odsBuilder, odsState, operands); }, "ods_builder"_a, "ods_state"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState){ return mlir::scf::ReduceOp::build(odsBuilder, odsState); }, "ods_builder"_a, "ods_state"_a)
.def("verify_invariants_impl", &mlir::scf::ReduceOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::ReduceOp::verifyInvariants)
.def("verify_regions", &mlir::scf::ReduceOp::verifyRegions)
.def("get_mutable_successor_operands", &mlir::scf::ReduceOp::getMutableSuccessorOperands, "point"_a)
.def_static("parse", &mlir::scf::ReduceOp::parse, "parser"_a, "result"_a)
;

auto mlir_detail_TypeIDResolver___mlir_scf_ReduceOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::ReduceOp>>(m, "TypeIDResolver[scf::ReduceOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::ReduceOp>::resolveTypeID)
;

auto mlir_scf_detail_ReduceReturnOpGenericAdaptorBase = nb::class_<mlir::scf::detail::ReduceReturnOpGenericAdaptorBase>(m, "ReduceReturnOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::ReduceReturnOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::scf::detail::ReduceReturnOpGenericAdaptorBase::getAttributes)
;

auto mlir_scf_ReduceReturnOpAdaptor = nb::class_<mlir::scf::ReduceReturnOpAdaptor>(m, "ReduceReturnOpAdaptor")
.def(nb::init<mlir::scf::ReduceReturnOp>(), "op"_a)
.def("verify", &mlir::scf::ReduceReturnOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_ReduceReturnOp = nb::class_<mlir::scf::ReduceReturnOp,  mlir::OpState>(m, "ReduceReturnOp")
.def_static("attribute_names", &mlir::scf::ReduceReturnOp::getAttributeNames)
.def_static("operation_name", &mlir::scf::ReduceReturnOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::ReduceReturnOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::ReduceReturnOp::getODSOperands, "index"_a)
.def_prop_ro("result", &mlir::scf::ReduceReturnOp::getResult)
.def_prop_ro("result_mutable", &mlir::scf::ReduceReturnOp::getResultMutable)
.def("get_ods_result_index_and_length", &mlir::scf::ReduceReturnOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::ReduceReturnOp::getODSResults, "index"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value result){ return mlir::scf::ReduceReturnOp::build(odsBuilder, odsState, result); }, "ods_builder"_a, "ods_state"_a, "result"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value result){ return mlir::scf::ReduceReturnOp::build(odsBuilder, odsState, resultTypes, result); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "result"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::scf::ReduceReturnOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::scf::ReduceReturnOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::ReduceReturnOp::verifyInvariants)
.def("verify", &mlir::scf::ReduceReturnOp::verify)
.def_static("parse", &mlir::scf::ReduceReturnOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::scf::ReduceReturnOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_scf_ReduceReturnOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::ReduceReturnOp>>(m, "TypeIDResolver[scf::ReduceReturnOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::ReduceReturnOp>::resolveTypeID)
;

auto mlir_scf_detail_WhileOpGenericAdaptorBase = nb::class_<mlir::scf::detail::WhileOpGenericAdaptorBase>(m, "WhileOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::WhileOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::scf::detail::WhileOpGenericAdaptorBase::getAttributes)
.def_prop_ro("before", &mlir::scf::detail::WhileOpGenericAdaptorBase::getBefore)
.def_prop_ro("after", &mlir::scf::detail::WhileOpGenericAdaptorBase::getAfter)
.def_prop_ro("regions", &mlir::scf::detail::WhileOpGenericAdaptorBase::getRegions)
;

auto mlir_scf_WhileOpAdaptor = nb::class_<mlir::scf::WhileOpAdaptor>(m, "WhileOpAdaptor")
.def(nb::init<mlir::scf::WhileOp>(), "op"_a)
.def("verify", &mlir::scf::WhileOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_WhileOp = nb::class_<mlir::scf::WhileOp,  mlir::OpState>(m, "WhileOp")
.def_static("attribute_names", &mlir::scf::WhileOp::getAttributeNames)
.def_static("operation_name", &mlir::scf::WhileOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::WhileOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::WhileOp::getODSOperands, "index"_a)
.def_prop_ro("inits", &mlir::scf::WhileOp::getInits)
.def_prop_ro("inits_mutable", &mlir::scf::WhileOp::getInitsMutable)
.def("get_ods_result_index_and_length", &mlir::scf::WhileOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::WhileOp::getODSResults, "index"_a)
.def_prop_ro("results", &mlir::scf::WhileOp::getResults)
.def_prop_ro("before", &mlir::scf::WhileOp::getBefore)
.def_prop_ro("after", &mlir::scf::WhileOp::getAfter)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange inits, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location, mlir::ValueRange)> beforeBuilder, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location, mlir::ValueRange)> afterBuilder){ return mlir::scf::WhileOp::build(odsBuilder, odsState, resultTypes, inits, beforeBuilder, afterBuilder); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "inits"_a, "before_builder"_a, "after_builder"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::scf::WhileOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::scf::WhileOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::scf::WhileOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::WhileOp::verifyInvariants)
.def("verify", &mlir::scf::WhileOp::verify)
.def_static("get_canonicalization_patterns", &mlir::scf::WhileOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("get_entry_successor_operands", &mlir::scf::WhileOp::getEntrySuccessorOperands, "point"_a)
.def("get_successor_regions", &mlir::scf::WhileOp::getSuccessorRegions, "point"_a, "regions"_a)
.def_prop_ro("loop_regions", &mlir::scf::WhileOp::getLoopRegions)
.def_prop_ro("region_iter_args", &mlir::scf::WhileOp::getRegionIterArgs)
.def_prop_ro("yielded_values_mutable", &mlir::scf::WhileOp::getYieldedValuesMutable)
.def_prop_ro("condition_op", &mlir::scf::WhileOp::getConditionOp)
.def_prop_ro("yield_op", &mlir::scf::WhileOp::getYieldOp)
.def_prop_ro("before_arguments", &mlir::scf::WhileOp::getBeforeArguments)
.def_prop_ro("after_arguments", &mlir::scf::WhileOp::getAfterArguments)
.def_prop_ro("before_body", &mlir::scf::WhileOp::getBeforeBody)
.def_prop_ro("after_body", &mlir::scf::WhileOp::getAfterBody)
;

auto mlir_detail_TypeIDResolver___mlir_scf_WhileOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::WhileOp>>(m, "TypeIDResolver[scf::WhileOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::WhileOp>::resolveTypeID)
;

auto mlir_scf_detail_YieldOpGenericAdaptorBase = nb::class_<mlir::scf::detail::YieldOpGenericAdaptorBase>(m, "YieldOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::scf::detail::YieldOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::scf::detail::YieldOpGenericAdaptorBase::getAttributes)
;

auto mlir_scf_YieldOpAdaptor = nb::class_<mlir::scf::YieldOpAdaptor>(m, "YieldOpAdaptor")
.def(nb::init<mlir::scf::YieldOp>(), "op"_a)
.def("verify", &mlir::scf::YieldOpAdaptor::verify, "loc"_a)
;

auto mlir_scf_YieldOp = nb::class_<mlir::scf::YieldOp,  mlir::OpState>(m, "YieldOp")
.def_static("attribute_names", &mlir::scf::YieldOp::getAttributeNames)
.def_static("operation_name", &mlir::scf::YieldOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::scf::YieldOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::scf::YieldOp::getODSOperands, "index"_a)
.def_prop_ro("results", &mlir::scf::YieldOp::getResults)
.def_prop_ro("results_mutable", &mlir::scf::YieldOp::getResultsMutable)
.def("get_ods_result_index_and_length", &mlir::scf::YieldOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::scf::YieldOp::getODSResults, "index"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState){ return mlir::scf::YieldOp::build(odsBuilder, odsState); }, "ods_builder"_a, "ods_state"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange results){ return mlir::scf::YieldOp::build(odsBuilder, odsState, results); }, "ods_builder"_a, "ods_state"_a, "results"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::scf::YieldOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::scf::YieldOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::scf::YieldOp::verifyInvariants)
.def("get_mutable_successor_operands", &mlir::scf::YieldOp::getMutableSuccessorOperands, "point"_a)
.def_static("parse", &mlir::scf::YieldOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::scf::YieldOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_scf_YieldOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::scf::YieldOp>>(m, "TypeIDResolver[scf::YieldOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::scf::YieldOp>::resolveTypeID)
;

auto mlir_scf_LoopNest = nb::class_<mlir::scf::LoopNest>(m, "LoopNest")
;

}
