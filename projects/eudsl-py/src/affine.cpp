
#include "ir.h"
#include "mlir/IR/IntegerSet.h";
#include "mlir/Dialect/Affine/IR/AffineValueMap.h"
namespace nb = nanobind;
using namespace nb::literals;
void populateAffineModule(nanobind::module_ & m) {
using namespace mlir;
using namespace mlir::detail;
using namespace mlir::affine;

auto mlir_affine_detail_AffineReadOpInterfaceInterfaceTraits = nb::class_<mlir::affine::detail::AffineReadOpInterfaceInterfaceTraits>(m, "AffineReadOpInterfaceInterfaceTraits")
;

auto mlir_affine_detail_AffineReadOpInterfaceInterfaceTraits_Concept = nb::class_<mlir::affine::detail::AffineReadOpInterfaceInterfaceTraits::Concept>(mlir_affine_detail_AffineReadOpInterfaceInterfaceTraits, "Concept")
;

auto mlir_affine_AffineReadOpInterface = nb::class_<mlir::affine::AffineReadOpInterface>(m, "AffineReadOpInterface")
.def_prop_ro("mem_ref", &mlir::affine::AffineReadOpInterface::getMemRef)
.def_prop_ro("mem_ref_type", &mlir::affine::AffineReadOpInterface::getMemRefType)
.def_prop_ro("map_operands", &mlir::affine::AffineReadOpInterface::getMapOperands)
.def_prop_ro("affine_map", &mlir::affine::AffineReadOpInterface::getAffineMap)
.def_prop_ro("value", &mlir::affine::AffineReadOpInterface::getValue)
;

auto mlir_affine_detail_AffineWriteOpInterfaceInterfaceTraits = nb::class_<mlir::affine::detail::AffineWriteOpInterfaceInterfaceTraits>(m, "AffineWriteOpInterfaceInterfaceTraits")
;

auto mlir_affine_detail_AffineWriteOpInterfaceInterfaceTraits_Concept = nb::class_<mlir::affine::detail::AffineWriteOpInterfaceInterfaceTraits::Concept>(mlir_affine_detail_AffineWriteOpInterfaceInterfaceTraits, "Concept")
;

auto mlir_affine_AffineWriteOpInterface = nb::class_<mlir::affine::AffineWriteOpInterface>(m, "AffineWriteOpInterface")
.def_prop_ro("mem_ref", &mlir::affine::AffineWriteOpInterface::getMemRef)
.def_prop_ro("mem_ref_type", &mlir::affine::AffineWriteOpInterface::getMemRefType)
.def_prop_ro("map_operands", &mlir::affine::AffineWriteOpInterface::getMapOperands)
.def_prop_ro("affine_map", &mlir::affine::AffineWriteOpInterface::getAffineMap)
.def_prop_ro("value_to_store", &mlir::affine::AffineWriteOpInterface::getValueToStore)
;

auto mlir_affine_detail_AffineMapAccessInterfaceInterfaceTraits = nb::class_<mlir::affine::detail::AffineMapAccessInterfaceInterfaceTraits>(m, "AffineMapAccessInterfaceInterfaceTraits")
;

auto mlir_affine_detail_AffineMapAccessInterfaceInterfaceTraits_Concept = nb::class_<mlir::affine::detail::AffineMapAccessInterfaceInterfaceTraits::Concept>(mlir_affine_detail_AffineMapAccessInterfaceInterfaceTraits, "Concept")
;

auto mlir_affine_AffineMapAccessInterface = nb::class_<mlir::affine::AffineMapAccessInterface>(m, "AffineMapAccessInterface")
.def("get_affine_map_attr_for_mem_ref", &mlir::affine::AffineMapAccessInterface::getAffineMapAttrForMemRef, "memref"_a)
;

auto mlir_affine_AffineDmaStartOp = nb::class_<mlir::affine::AffineDmaStartOp,  mlir::OpState>(m, "AffineDmaStartOp")
.def_static("attribute_names", &mlir::affine::AffineDmaStartOp::getAttributeNames)
.def_static("build", &mlir::affine::AffineDmaStartOp::build, "builder"_a, "result"_a, "src_mem_ref"_a, "src_map"_a, "src_indices"_a, "dest_mem_ref"_a, "dst_map"_a, "dest_indices"_a, "tag_mem_ref"_a, "tag_map"_a, "tag_indices"_a, "num_elements"_a, "stride"_a, "elements_per_stride"_a)
.def_prop_ro("src_mem_ref_operand_index", &mlir::affine::AffineDmaStartOp::getSrcMemRefOperandIndex)
.def_prop_ro("src_mem_ref", &mlir::affine::AffineDmaStartOp::getSrcMemRef)
.def_prop_ro("src_mem_ref_mutable", &mlir::affine::AffineDmaStartOp::getSrcMemRefMutable)
.def_prop_ro("src_mem_ref_type", &mlir::affine::AffineDmaStartOp::getSrcMemRefType)
.def_prop_ro("src_mem_ref_rank", &mlir::affine::AffineDmaStartOp::getSrcMemRefRank)
.def_prop_ro("src_map", &mlir::affine::AffineDmaStartOp::getSrcMap)
.def_prop_ro("src_map_attr", &mlir::affine::AffineDmaStartOp::getSrcMapAttr)
.def_prop_ro("src_indices", &mlir::affine::AffineDmaStartOp::getSrcIndices)
.def_prop_ro("src_memory_space", &mlir::affine::AffineDmaStartOp::getSrcMemorySpace)
.def_prop_ro("dst_mem_ref_operand_index", &mlir::affine::AffineDmaStartOp::getDstMemRefOperandIndex)
.def_prop_ro("dst_mem_ref", &mlir::affine::AffineDmaStartOp::getDstMemRef)
.def_prop_ro("dst_mem_ref_mutable", &mlir::affine::AffineDmaStartOp::getDstMemRefMutable)
.def_prop_ro("dst_mem_ref_type", &mlir::affine::AffineDmaStartOp::getDstMemRefType)
.def_prop_ro("dst_mem_ref_rank", &mlir::affine::AffineDmaStartOp::getDstMemRefRank)
.def_prop_ro("dst_memory_space", &mlir::affine::AffineDmaStartOp::getDstMemorySpace)
.def_prop_ro("dst_map", &mlir::affine::AffineDmaStartOp::getDstMap)
.def_prop_ro("dst_map_attr", &mlir::affine::AffineDmaStartOp::getDstMapAttr)
.def_prop_ro("dst_indices", &mlir::affine::AffineDmaStartOp::getDstIndices)
.def_prop_ro("tag_mem_ref_operand_index", &mlir::affine::AffineDmaStartOp::getTagMemRefOperandIndex)
.def_prop_ro("tag_mem_ref", &mlir::affine::AffineDmaStartOp::getTagMemRef)
.def_prop_ro("tag_mem_ref_mutable", &mlir::affine::AffineDmaStartOp::getTagMemRefMutable)
.def_prop_ro("tag_mem_ref_type", &mlir::affine::AffineDmaStartOp::getTagMemRefType)
.def_prop_ro("tag_mem_ref_rank", &mlir::affine::AffineDmaStartOp::getTagMemRefRank)
.def_prop_ro("tag_map", &mlir::affine::AffineDmaStartOp::getTagMap)
.def_prop_ro("tag_map_attr", &mlir::affine::AffineDmaStartOp::getTagMapAttr)
.def_prop_ro("tag_indices", &mlir::affine::AffineDmaStartOp::getTagIndices)
.def_prop_ro("num_elements", &mlir::affine::AffineDmaStartOp::getNumElements)
.def("get_affine_map_attr_for_mem_ref", &mlir::affine::AffineDmaStartOp::getAffineMapAttrForMemRef, "memref"_a)
.def("is_dest_memory_space_faster", &mlir::affine::AffineDmaStartOp::isDestMemorySpaceFaster)
.def("is_src_memory_space_faster", &mlir::affine::AffineDmaStartOp::isSrcMemorySpaceFaster)
.def_prop_ro("faster_mem_pos", &mlir::affine::AffineDmaStartOp::getFasterMemPos)
.def("get_effects", &mlir::affine::AffineDmaStartOp::getEffects, "effects"_a)
.def_static("src_map_attr_str_name", &mlir::affine::AffineDmaStartOp::getSrcMapAttrStrName)
.def_static("dst_map_attr_str_name", &mlir::affine::AffineDmaStartOp::getDstMapAttrStrName)
.def_static("tag_map_attr_str_name", &mlir::affine::AffineDmaStartOp::getTagMapAttrStrName)
.def_static("operation_name", &mlir::affine::AffineDmaStartOp::getOperationName)
.def_static("parse", &mlir::affine::AffineDmaStartOp::parse, "parser"_a, "result"_a)
.def("print", &mlir::affine::AffineDmaStartOp::print, "p"_a)
.def("verify_invariants_impl", &mlir::affine::AffineDmaStartOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineDmaStartOp::verifyInvariants)
.def("fold", &mlir::affine::AffineDmaStartOp::fold, "cst_operands"_a, "results"_a)
.def("is_strided", &mlir::affine::AffineDmaStartOp::isStrided)
.def_prop_ro("stride", &mlir::affine::AffineDmaStartOp::getStride)
.def_prop_ro("num_elements_per_stride", &mlir::affine::AffineDmaStartOp::getNumElementsPerStride)
;

auto mlir_affine_AffineDmaWaitOp = nb::class_<mlir::affine::AffineDmaWaitOp,  mlir::OpState>(m, "AffineDmaWaitOp")
.def_static("attribute_names", &mlir::affine::AffineDmaWaitOp::getAttributeNames)
.def_static("build", &mlir::affine::AffineDmaWaitOp::build, "builder"_a, "result"_a, "tag_mem_ref"_a, "tag_map"_a, "tag_indices"_a, "num_elements"_a)
.def_static("operation_name", &mlir::affine::AffineDmaWaitOp::getOperationName)
.def_prop_ro("tag_mem_ref", &mlir::affine::AffineDmaWaitOp::getTagMemRef)
.def_prop_ro("tag_mem_ref_mutable", &mlir::affine::AffineDmaWaitOp::getTagMemRefMutable)
.def_prop_ro("tag_mem_ref_type", &mlir::affine::AffineDmaWaitOp::getTagMemRefType)
.def_prop_ro("tag_map", &mlir::affine::AffineDmaWaitOp::getTagMap)
.def_prop_ro("tag_map_attr", &mlir::affine::AffineDmaWaitOp::getTagMapAttr)
.def_prop_ro("tag_indices", &mlir::affine::AffineDmaWaitOp::getTagIndices)
.def_prop_ro("tag_mem_ref_rank", &mlir::affine::AffineDmaWaitOp::getTagMemRefRank)
.def("get_affine_map_attr_for_mem_ref", &mlir::affine::AffineDmaWaitOp::getAffineMapAttrForMemRef, "memref"_a)
.def_prop_ro("num_elements", &mlir::affine::AffineDmaWaitOp::getNumElements)
.def_static("tag_map_attr_str_name", &mlir::affine::AffineDmaWaitOp::getTagMapAttrStrName)
.def_static("parse", &mlir::affine::AffineDmaWaitOp::parse, "parser"_a, "result"_a)
.def("print", &mlir::affine::AffineDmaWaitOp::print, "p"_a)
.def("verify_invariants_impl", &mlir::affine::AffineDmaWaitOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineDmaWaitOp::verifyInvariants)
.def("fold", &mlir::affine::AffineDmaWaitOp::fold, "cst_operands"_a, "results"_a)
.def("get_effects", &mlir::affine::AffineDmaWaitOp::getEffects, "effects"_a)
;

auto mlir_affine_AffineDialect = nb::class_<mlir::affine::AffineDialect, mlir::Dialect>(m, "AffineDialect")
.def_static("dialect_namespace", &mlir::affine::AffineDialect::getDialectNamespace)
.def("materialize_constant", &mlir::affine::AffineDialect::materializeConstant, "builder"_a, "value"_a, "type"_a, "loc"_a, nb::rv_policy::reference_internal)
.def_static("insert_into_registry", [](mlir::DialectRegistry &registry) { registry.insert<mlir::affine::AffineDialect>(); })
.def_static("load_into_context", [](mlir::MLIRContext &context) { return context.getOrLoadDialect<mlir::affine::AffineDialect>(); })
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineDialect__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineDialect>>(m, "TypeIDResolver[affine::AffineDialect]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineDialect>::resolveTypeID)
;

auto mlir_affine_detail_AffineApplyOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineApplyOpGenericAdaptorBase>(m, "AffineApplyOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineApplyOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineApplyOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineApplyOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineApplyOpGenericAdaptorBase::getAttributes)
.def_prop_ro("map_attr", &mlir::affine::detail::AffineApplyOpGenericAdaptorBase::getMapAttr)
.def_prop_ro("map", &mlir::affine::detail::AffineApplyOpGenericAdaptorBase::getMap)
;

auto mlir_affine_detail_AffineApplyOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineApplyOpGenericAdaptorBase, "Properties")
.def_prop_ro("map", &mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties::getMap)
.def("set_map", &mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties::setMap, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineApplyOpAdaptor = nb::class_<mlir::affine::AffineApplyOpAdaptor>(m, "AffineApplyOpAdaptor")
.def(nb::init<mlir::affine::AffineApplyOp>(), "op"_a)
.def("verify", &mlir::affine::AffineApplyOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineApplyOp = nb::class_<mlir::affine::AffineApplyOp,  mlir::OpState>(m, "AffineApplyOp")
.def_static("attribute_names", &mlir::affine::AffineApplyOp::getAttributeNames)
.def_prop_ro("map_attr_name", [](mlir::affine::AffineApplyOp& self){ return self.getMapAttrName(); })
.def_static("get_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineApplyOp::getMapAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineApplyOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineApplyOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineApplyOp::getODSOperands, "index"_a)
.def_prop_ro("map_operands", &mlir::affine::AffineApplyOp::getMapOperands)
.def_prop_ro("map_operands_mutable", &mlir::affine::AffineApplyOp::getMapOperandsMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineApplyOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineApplyOp::getODSResults, "index"_a)
.def_static("set_properties_from_attr", &mlir::affine::AffineApplyOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineApplyOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineApplyOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineApplyOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineApplyOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineApplyOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineApplyOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineApplyOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineApplyOp::writeProperties, "writer"_a)
.def_prop_ro("map_attr", &mlir::affine::AffineApplyOp::getMapAttr)
.def_prop_ro("map", &mlir::affine::AffineApplyOp::getMap)
.def("set_map_attr", &mlir::affine::AffineApplyOp::setMapAttr, "attr"_a)
.def("set_map", &mlir::affine::AffineApplyOp::setMap, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, llvm::ArrayRef<mlir::AffineExpr> exprList, mlir::ValueRange mapOperands){ return mlir::affine::AffineApplyOp::build(odsBuilder, odsState, exprList, mapOperands); }, "ods_builder"_a, "ods_state"_a, "expr_list"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type resultType0, mlir::AffineMapAttr map, mlir::ValueRange mapOperands){ return mlir::affine::AffineApplyOp::build(odsBuilder, odsState, resultType0, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "result_type0"_a, "map"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::AffineMapAttr map, mlir::ValueRange mapOperands){ return mlir::affine::AffineApplyOp::build(odsBuilder, odsState, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "map"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::AffineMapAttr map, mlir::ValueRange mapOperands){ return mlir::affine::AffineApplyOp::build(odsBuilder, odsState, resultTypes, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "map"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type resultType0, mlir::AffineMap map, mlir::ValueRange mapOperands){ return mlir::affine::AffineApplyOp::build(odsBuilder, odsState, resultType0, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "result_type0"_a, "map"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::AffineMap map, mlir::ValueRange mapOperands){ return mlir::affine::AffineApplyOp::build(odsBuilder, odsState, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "map"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::AffineMap map, mlir::ValueRange mapOperands){ return mlir::affine::AffineApplyOp::build(odsBuilder, odsState, resultTypes, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "map"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineApplyOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineApplyOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::affine::AffineApplyOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineApplyOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineApplyOp::verifyInvariants)
.def("verify", &mlir::affine::AffineApplyOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineApplyOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffineApplyOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::affine::AffineApplyOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("get_effects", &mlir::affine::AffineApplyOp::getEffects, "effects"_a)
.def_prop_ro("affine_map", &mlir::affine::AffineApplyOp::getAffineMap)
.def_prop_ro("affine_value_map", &mlir::affine::AffineApplyOp::getAffineValueMap)
.def("is_valid_dim", [](mlir::affine::AffineApplyOp& self){ return self.isValidDim(); })
.def("is_valid_dim", [](mlir::affine::AffineApplyOp& self, mlir::Region * region){ return self.isValidDim(region); }, "region"_a)
.def("is_valid_symbol", [](mlir::affine::AffineApplyOp& self){ return self.isValidSymbol(); })
.def("is_valid_symbol", [](mlir::affine::AffineApplyOp& self, mlir::Region * region){ return self.isValidSymbol(region); }, "region"_a)
.def_prop_ro("dim_operands", &mlir::affine::AffineApplyOp::getDimOperands)
.def_prop_ro("symbol_operands", &mlir::affine::AffineApplyOp::getSymbolOperands)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineApplyOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineApplyOp>>(m, "TypeIDResolver[affine::AffineApplyOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineApplyOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineDelinearizeIndexOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase>(m, "AffineDelinearizeIndexOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineDelinearizeIndexOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::getAttributes)
.def_prop_ro("static_basis_attr", &mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::getStaticBasisAttr)
.def_prop_ro("static_basis", &mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::getStaticBasis)
;

auto mlir_affine_detail_AffineDelinearizeIndexOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineDelinearizeIndexOpGenericAdaptorBase, "Properties")
.def_prop_ro("static_basis", &mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::Properties::getStaticBasis)
.def("set_static_basis", &mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::Properties::setStaticBasis, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineDelinearizeIndexOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineDelinearizeIndexOpAdaptor = nb::class_<mlir::affine::AffineDelinearizeIndexOpAdaptor>(m, "AffineDelinearizeIndexOpAdaptor")
.def(nb::init<mlir::affine::AffineDelinearizeIndexOp>(), "op"_a)
.def("verify", &mlir::affine::AffineDelinearizeIndexOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineDelinearizeIndexOp = nb::class_<mlir::affine::AffineDelinearizeIndexOp,  mlir::OpState>(m, "AffineDelinearizeIndexOp")
.def_static("attribute_names", &mlir::affine::AffineDelinearizeIndexOp::getAttributeNames)
.def_prop_ro("static_basis_attr_name", [](mlir::affine::AffineDelinearizeIndexOp& self){ return self.getStaticBasisAttrName(); })
.def_static("get_static_basis_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineDelinearizeIndexOp::getStaticBasisAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineDelinearizeIndexOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineDelinearizeIndexOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineDelinearizeIndexOp::getODSOperands, "index"_a)
.def_prop_ro("linear_index", &mlir::affine::AffineDelinearizeIndexOp::getLinearIndex)
.def_prop_ro("dynamic_basis", &mlir::affine::AffineDelinearizeIndexOp::getDynamicBasis)
.def_prop_ro("linear_index_mutable", &mlir::affine::AffineDelinearizeIndexOp::getLinearIndexMutable)
.def_prop_ro("dynamic_basis_mutable", &mlir::affine::AffineDelinearizeIndexOp::getDynamicBasisMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineDelinearizeIndexOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineDelinearizeIndexOp::getODSResults, "index"_a)
.def_prop_ro("multi_index", &mlir::affine::AffineDelinearizeIndexOp::getMultiIndex)
.def_static("set_properties_from_attr", &mlir::affine::AffineDelinearizeIndexOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineDelinearizeIndexOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineDelinearizeIndexOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineDelinearizeIndexOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineDelinearizeIndexOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineDelinearizeIndexOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineDelinearizeIndexOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineDelinearizeIndexOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineDelinearizeIndexOp::writeProperties, "writer"_a)
.def_prop_ro("static_basis_attr", &mlir::affine::AffineDelinearizeIndexOp::getStaticBasisAttr)
.def_prop_ro("static_basis", &mlir::affine::AffineDelinearizeIndexOp::getStaticBasis)
.def("set_static_basis_attr", &mlir::affine::AffineDelinearizeIndexOp::setStaticBasisAttr, "attr"_a)
.def("set_static_basis", &mlir::affine::AffineDelinearizeIndexOp::setStaticBasis, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value linear_index, mlir::ValueRange dynamic_basis, ArrayRef<int64_t> static_asis, bool hasOuterBound){ return mlir::affine::AffineDelinearizeIndexOp::build(odsBuilder, odsState, linear_index, dynamic_basis, static_asis, hasOuterBound); }, "ods_builder"_a, "ods_state"_a, "linear_index"_a, "dynamic_basis"_a, "static_asis"_a, "has_outer_bound"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value linear_index, mlir::ValueRange basis, bool hasOuterBound){ return mlir::affine::AffineDelinearizeIndexOp::build(odsBuilder, odsState, linear_index, basis, hasOuterBound); }, "ods_builder"_a, "ods_state"_a, "linear_index"_a, "basis"_a, "has_outer_bound"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value linear_index, llvm::ArrayRef<mlir::OpFoldResult> basis, bool hasOuterBound){ return mlir::affine::AffineDelinearizeIndexOp::build(odsBuilder, odsState, linear_index, basis, hasOuterBound); }, "ods_builder"_a, "ods_state"_a, "linear_index"_a, "basis"_a, "has_outer_bound"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value linear_index, ArrayRef<int64_t> basis, bool hasOuterBound){ return mlir::affine::AffineDelinearizeIndexOp::build(odsBuilder, odsState, linear_index, basis, hasOuterBound); }, "ods_builder"_a, "ods_state"_a, "linear_index"_a, "basis"_a, "has_outer_bound"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange multi_index, mlir::Value linear_index, mlir::ValueRange dynamic_basis, mlir::detail::DenseArrayAttrImpl<int64_t> static_basis){ return mlir::affine::AffineDelinearizeIndexOp::build(odsBuilder, odsState, multi_index, linear_index, dynamic_basis, static_basis); }, "ods_builder"_a, "ods_state"_a, "multi_index"_a, "linear_index"_a, "dynamic_basis"_a, "static_basis"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange multi_index, mlir::Value linear_index, mlir::ValueRange dynamic_basis, ::llvm::ArrayRef<int64_t> static_basis){ return mlir::affine::AffineDelinearizeIndexOp::build(odsBuilder, odsState, multi_index, linear_index, dynamic_basis, static_basis); }, "ods_builder"_a, "ods_state"_a, "multi_index"_a, "linear_index"_a, "dynamic_basis"_a, "static_basis"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineDelinearizeIndexOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::affine::AffineDelinearizeIndexOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineDelinearizeIndexOp::verifyInvariants)
.def("verify", &mlir::affine::AffineDelinearizeIndexOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineDelinearizeIndexOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffineDelinearizeIndexOp::fold, "adaptor"_a, "results"_a)
.def_static("parse", &mlir::affine::AffineDelinearizeIndexOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::affine::AffineDelinearizeIndexOp::getEffects, "effects"_a)
.def("has_outer_bound", &mlir::affine::AffineDelinearizeIndexOp::hasOuterBound)
.def_prop_ro("mixed_basis", &mlir::affine::AffineDelinearizeIndexOp::getMixedBasis)
.def_prop_ro("effective_basis", &mlir::affine::AffineDelinearizeIndexOp::getEffectiveBasis)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineDelinearizeIndexOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineDelinearizeIndexOp>>(m, "TypeIDResolver[affine::AffineDelinearizeIndexOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineDelinearizeIndexOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineForOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineForOpGenericAdaptorBase>(m, "AffineForOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineForOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getAttributes)
.def_prop_ro("lower_bound_map_attr", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getLowerBoundMapAttr)
.def_prop_ro("lower_bound_map", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getLowerBoundMap)
.def_prop_ro("upper_bound_map_attr", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getUpperBoundMapAttr)
.def_prop_ro("upper_bound_map", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getUpperBoundMap)
.def_prop_ro("step_attr", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getStepAttr)
.def_prop_ro("step", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getStep)
.def_prop_ro("region", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getRegion)
.def_prop_ro("regions", &mlir::affine::detail::AffineForOpGenericAdaptorBase::getRegions)
;

auto mlir_affine_detail_AffineForOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineForOpGenericAdaptorBase, "Properties")
.def_prop_ro("lower_bound_map", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::getLowerBoundMap)
.def("set_lower_bound_map", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::setLowerBoundMap, "prop_value"_a)
.def_prop_ro("step", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::getStep)
.def("set_step", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::setStep, "prop_value"_a)
.def_prop_ro("upper_bound_map", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::getUpperBoundMap)
.def("set_upper_bound_map", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::setUpperBoundMap, "prop_value"_a)
.def_prop_ro("operand_segment_sizes", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::getOperandSegmentSizes)
.def("set_operand_segment_sizes", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::setOperandSegmentSizes, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineForOpAdaptor = nb::class_<mlir::affine::AffineForOpAdaptor>(m, "AffineForOpAdaptor")
.def(nb::init<mlir::affine::AffineForOp>(), "op"_a)
.def("verify", &mlir::affine::AffineForOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineForOp = nb::class_<mlir::affine::AffineForOp,  mlir::OpState>(m, "AffineForOp")
.def_static("attribute_names", &mlir::affine::AffineForOp::getAttributeNames)
.def_prop_ro("lower_bound_map_attr_name", [](mlir::affine::AffineForOp& self){ return self.getLowerBoundMapAttrName(); })
.def_static("get_lower_bound_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineForOp::getLowerBoundMapAttrName(name); }, "name"_a)
.def_prop_ro("step_attr_name", [](mlir::affine::AffineForOp& self){ return self.getStepAttrName(); })
.def_static("get_step_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineForOp::getStepAttrName(name); }, "name"_a)
.def_prop_ro("upper_bound_map_attr_name", [](mlir::affine::AffineForOp& self){ return self.getUpperBoundMapAttrName(); })
.def_static("get_upper_bound_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineForOp::getUpperBoundMapAttrName(name); }, "name"_a)
.def_prop_ro("operand_segment_sizes_attr_name", [](mlir::affine::AffineForOp& self){ return self.getOperandSegmentSizesAttrName(); })
.def_static("get_operand_segment_sizes_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineForOp::getOperandSegmentSizesAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineForOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineForOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineForOp::getODSOperands, "index"_a)
.def_prop_ro("lower_bound_operands", &mlir::affine::AffineForOp::getLowerBoundOperands)
.def_prop_ro("upper_bound_operands", &mlir::affine::AffineForOp::getUpperBoundOperands)
.def_prop_ro("inits", &mlir::affine::AffineForOp::getInits)
.def_prop_ro("lower_bound_operands_mutable", &mlir::affine::AffineForOp::getLowerBoundOperandsMutable)
.def_prop_ro("upper_bound_operands_mutable", &mlir::affine::AffineForOp::getUpperBoundOperandsMutable)
.def_prop_ro("inits_mutable", &mlir::affine::AffineForOp::getInitsMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineForOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineForOp::getODSResults, "index"_a)
.def_prop_ro("results", &mlir::affine::AffineForOp::getResults)
.def_prop_ro("region", &mlir::affine::AffineForOp::getRegion)
.def_static("set_properties_from_attr", &mlir::affine::AffineForOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineForOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineForOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineForOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineForOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineForOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineForOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineForOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineForOp::writeProperties, "writer"_a)
.def_prop_ro("lower_bound_map_attr", &mlir::affine::AffineForOp::getLowerBoundMapAttr)
.def_prop_ro("lower_bound_map", &mlir::affine::AffineForOp::getLowerBoundMap)
.def_prop_ro("upper_bound_map_attr", &mlir::affine::AffineForOp::getUpperBoundMapAttr)
.def_prop_ro("upper_bound_map", &mlir::affine::AffineForOp::getUpperBoundMap)
.def_prop_ro("step_attr", &mlir::affine::AffineForOp::getStepAttr)
.def_prop_ro("step", &mlir::affine::AffineForOp::getStep)
.def("set_lower_bound_map_attr", &mlir::affine::AffineForOp::setLowerBoundMapAttr, "attr"_a)
.def("set_lower_bound_map", &mlir::affine::AffineForOp::setLowerBoundMap, "attr_value"_a)
.def("set_upper_bound_map_attr", &mlir::affine::AffineForOp::setUpperBoundMapAttr, "attr"_a)
.def("set_upper_bound_map", &mlir::affine::AffineForOp::setUpperBoundMap, "attr_value"_a)
.def("set_step_attr", &mlir::affine::AffineForOp::setStepAttr, "attr"_a)
.def("set_step", [](mlir::affine::AffineForOp& self, llvm::APInt attrValue){ return self.setStep(attrValue); }, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, int64_t lowerBound, int64_t upperBound, int64_t step, mlir::ValueRange iterArgs, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location, mlir::Value, mlir::ValueRange)> bodyBuilder){ return mlir::affine::AffineForOp::build(odsBuilder, odsState, lowerBound, upperBound, step, iterArgs, bodyBuilder); }, "ods_builder"_a, "ods_state"_a, "lower_bound"_a, "upper_bound"_a, "step"_a, "iter_args"_a, "body_builder"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange lbOperands, mlir::AffineMap lbMap, mlir::ValueRange ubOperands, mlir::AffineMap ubMap, int64_t step, mlir::ValueRange iterArgs, llvm::function_ref<void (mlir::OpBuilder &, mlir::Location, mlir::Value, mlir::ValueRange)> bodyBuilder){ return mlir::affine::AffineForOp::build(odsBuilder, odsState, lbOperands, lbMap, ubOperands, ubMap, step, iterArgs, bodyBuilder); }, "ods_builder"_a, "ods_state"_a, "lb_operands"_a, "lb_map"_a, "ub_operands"_a, "ub_map"_a, "step"_a, "iter_args"_a, "body_builder"_a)
.def_static("parse", &mlir::affine::AffineForOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineForOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineForOp::verifyInvariants)
.def("verify_regions", &mlir::affine::AffineForOp::verifyRegions)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineForOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffineForOp::fold, "adaptor"_a, "results"_a)
.def_prop_ro("loop_regions", &mlir::affine::AffineForOp::getLoopRegions)
.def_prop_ro("loop_induction_vars", &mlir::affine::AffineForOp::getLoopInductionVars)
.def_prop_ro("loop_lower_bounds", &mlir::affine::AffineForOp::getLoopLowerBounds)
.def_prop_ro("loop_steps", &mlir::affine::AffineForOp::getLoopSteps)
.def_prop_ro("loop_upper_bounds", &mlir::affine::AffineForOp::getLoopUpperBounds)
.def_prop_ro("yielded_values_mutable", &mlir::affine::AffineForOp::getYieldedValuesMutable)
.def("replace_with_additional_yields", &mlir::affine::AffineForOp::replaceWithAdditionalYields, "rewriter"_a, "new_init_operands"_a, "replace_init_operand_uses_in_loop"_a, "new_yield_values_fn"_a)
.def("get_entry_successor_operands", &mlir::affine::AffineForOp::getEntrySuccessorOperands, "point"_a)
.def("get_successor_regions", &mlir::affine::AffineForOp::getSuccessorRegions, "point"_a, "regions"_a)
.def_prop_ro("induction_var", &mlir::affine::AffineForOp::getInductionVar)
.def_prop_ro("region_iter_args", &mlir::affine::AffineForOp::getRegionIterArgs)
.def_prop_ro("control_operands", &mlir::affine::AffineForOp::getControlOperands)
.def_prop_ro("lower_bound", &mlir::affine::AffineForOp::getLowerBound)
.def_prop_ro("upper_bound", &mlir::affine::AffineForOp::getUpperBound)
.def_prop_ro("step_as_int", &mlir::affine::AffineForOp::getStepAsInt)
.def("set_lower_bound", &mlir::affine::AffineForOp::setLowerBound, "operands"_a, "map"_a)
.def("set_upper_bound", &mlir::affine::AffineForOp::setUpperBound, "operands"_a, "map"_a)
.def("set_step", [](mlir::affine::AffineForOp& self, int64_t step){ return self.setStep(step); }, "step"_a)
.def_prop_ro("num_region_iter_args", &mlir::affine::AffineForOp::getNumRegionIterArgs)
.def_prop_ro("num_control_operands", &mlir::affine::AffineForOp::getNumControlOperands)
.def_prop_ro("num_iter_operands", &mlir::affine::AffineForOp::getNumIterOperands)
.def("has_constant_lower_bound", &mlir::affine::AffineForOp::hasConstantLowerBound)
.def("has_constant_upper_bound", &mlir::affine::AffineForOp::hasConstantUpperBound)
.def("has_constant_bounds", &mlir::affine::AffineForOp::hasConstantBounds)
.def_prop_ro("constant_lower_bound", &mlir::affine::AffineForOp::getConstantLowerBound)
.def_prop_ro("constant_upper_bound", &mlir::affine::AffineForOp::getConstantUpperBound)
.def("set_constant_lower_bound", &mlir::affine::AffineForOp::setConstantLowerBound, "value"_a)
.def("set_constant_upper_bound", &mlir::affine::AffineForOp::setConstantUpperBound, "value"_a)
.def("matching_bound_operand_list", &mlir::affine::AffineForOp::matchingBoundOperandList)
.def_prop_ro("speculatability", &mlir::affine::AffineForOp::getSpeculatability)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineForOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineForOp>>(m, "TypeIDResolver[affine::AffineForOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineForOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineIfOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineIfOpGenericAdaptorBase>(m, "AffineIfOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineIfOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineIfOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::getAttributes)
.def_prop_ro("condition_attr", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::getConditionAttr)
.def_prop_ro("condition", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::getCondition)
.def_prop_ro("then_region", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::getThenRegion)
.def_prop_ro("else_region", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::getElseRegion)
.def_prop_ro("regions", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::getRegions)
;

auto mlir_affine_detail_AffineIfOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineIfOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineIfOpGenericAdaptorBase, "Properties")
.def_prop_ro("condition", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::Properties::getCondition)
.def("set_condition", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::Properties::setCondition, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineIfOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineIfOpAdaptor = nb::class_<mlir::affine::AffineIfOpAdaptor>(m, "AffineIfOpAdaptor")
.def(nb::init<mlir::affine::AffineIfOp>(), "op"_a)
.def("verify", &mlir::affine::AffineIfOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineIfOp = nb::class_<mlir::affine::AffineIfOp,  mlir::OpState>(m, "AffineIfOp")
.def_static("attribute_names", &mlir::affine::AffineIfOp::getAttributeNames)
.def_prop_ro("condition_attr_name", [](mlir::affine::AffineIfOp& self){ return self.getConditionAttrName(); })
.def_static("get_condition_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineIfOp::getConditionAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineIfOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineIfOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineIfOp::getODSOperands, "index"_a)
.def("get_ods_result_index_and_length", &mlir::affine::AffineIfOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineIfOp::getODSResults, "index"_a)
.def_prop_ro("results", &mlir::affine::AffineIfOp::getResults)
.def_prop_ro("then_region", &mlir::affine::AffineIfOp::getThenRegion)
.def_prop_ro("else_region", &mlir::affine::AffineIfOp::getElseRegion)
.def_static("set_properties_from_attr", &mlir::affine::AffineIfOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineIfOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineIfOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineIfOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineIfOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineIfOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineIfOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineIfOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineIfOp::writeProperties, "writer"_a)
.def_prop_ro("condition_attr", &mlir::affine::AffineIfOp::getConditionAttr)
.def_prop_ro("condition", &mlir::affine::AffineIfOp::getCondition)
.def("set_condition_attr", &mlir::affine::AffineIfOp::setConditionAttr, "attr"_a)
.def("set_condition", &mlir::affine::AffineIfOp::setCondition, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::IntegerSet set, mlir::ValueRange args, bool withElseRegion){ return mlir::affine::AffineIfOp::build(odsBuilder, odsState, set, args, withElseRegion); }, "ods_builder"_a, "ods_state"_a, "set"_a, "args"_a, "with_else_region"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::IntegerSet set, mlir::ValueRange args, bool withElseRegion){ return mlir::affine::AffineIfOp::build(odsBuilder, odsState, resultTypes, set, args, withElseRegion); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "set"_a, "args"_a, "with_else_region"_a)
.def_static("parse", &mlir::affine::AffineIfOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineIfOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineIfOp::verifyInvariants)
.def("verify", &mlir::affine::AffineIfOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineIfOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffineIfOp::fold, "adaptor"_a, "results"_a)
.def("get_successor_regions", &mlir::affine::AffineIfOp::getSuccessorRegions, "point"_a, "regions"_a)
.def_static("condition_attr_str_name", &mlir::affine::AffineIfOp::getConditionAttrStrName)
.def_prop_ro("integer_set", &mlir::affine::AffineIfOp::getIntegerSet)
.def("set_integer_set", &mlir::affine::AffineIfOp::setIntegerSet, "new_set"_a)
.def("set_conditional", &mlir::affine::AffineIfOp::setConditional, "set"_a, "operands"_a)
.def("has_else", &mlir::affine::AffineIfOp::hasElse)
.def_prop_ro("then_block", &mlir::affine::AffineIfOp::getThenBlock)
.def_prop_ro("else_block", &mlir::affine::AffineIfOp::getElseBlock)
.def_prop_ro("then_body_builder", &mlir::affine::AffineIfOp::getThenBodyBuilder)
.def_prop_ro("else_body_builder", &mlir::affine::AffineIfOp::getElseBodyBuilder)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineIfOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineIfOp>>(m, "TypeIDResolver[affine::AffineIfOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineIfOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineLinearizeIndexOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase>(m, "AffineLinearizeIndexOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineLinearizeIndexOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::getAttributes)
.def_prop_ro("disjoint", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::getDisjoint)
.def_prop_ro("static_basis_attr", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::getStaticBasisAttr)
.def_prop_ro("static_basis", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::getStaticBasis)
;

auto mlir_affine_detail_AffineLinearizeIndexOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineLinearizeIndexOpGenericAdaptorBase, "Properties")
.def_prop_ro("static_basis", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties::getStaticBasis)
.def("set_static_basis", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties::setStaticBasis, "prop_value"_a)
.def_prop_ro("disjoint", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties::getDisjoint)
.def("set_disjoint", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties::setDisjoint, "prop_value"_a)
.def_prop_ro("operand_segment_sizes", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties::getOperandSegmentSizes)
.def("set_operand_segment_sizes", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties::setOperandSegmentSizes, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineLinearizeIndexOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineLinearizeIndexOpAdaptor = nb::class_<mlir::affine::AffineLinearizeIndexOpAdaptor>(m, "AffineLinearizeIndexOpAdaptor")
.def(nb::init<mlir::affine::AffineLinearizeIndexOp>(), "op"_a)
.def("verify", &mlir::affine::AffineLinearizeIndexOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineLinearizeIndexOp = nb::class_<mlir::affine::AffineLinearizeIndexOp,  mlir::OpState>(m, "AffineLinearizeIndexOp")
.def_static("attribute_names", &mlir::affine::AffineLinearizeIndexOp::getAttributeNames)
.def_prop_ro("static_basis_attr_name", [](mlir::affine::AffineLinearizeIndexOp& self){ return self.getStaticBasisAttrName(); })
.def_static("get_static_basis_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineLinearizeIndexOp::getStaticBasisAttrName(name); }, "name"_a)
.def_prop_ro("operand_segment_sizes_attr_name", [](mlir::affine::AffineLinearizeIndexOp& self){ return self.getOperandSegmentSizesAttrName(); })
.def_static("get_operand_segment_sizes_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineLinearizeIndexOp::getOperandSegmentSizesAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineLinearizeIndexOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineLinearizeIndexOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineLinearizeIndexOp::getODSOperands, "index"_a)
.def_prop_ro("multi_index", &mlir::affine::AffineLinearizeIndexOp::getMultiIndex)
.def_prop_ro("dynamic_basis", &mlir::affine::AffineLinearizeIndexOp::getDynamicBasis)
.def_prop_ro("multi_index_mutable", &mlir::affine::AffineLinearizeIndexOp::getMultiIndexMutable)
.def_prop_ro("dynamic_basis_mutable", &mlir::affine::AffineLinearizeIndexOp::getDynamicBasisMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineLinearizeIndexOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineLinearizeIndexOp::getODSResults, "index"_a)
.def_prop_ro("linear_index", &mlir::affine::AffineLinearizeIndexOp::getLinearIndex)
.def_static("set_properties_from_attr", &mlir::affine::AffineLinearizeIndexOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineLinearizeIndexOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineLinearizeIndexOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineLinearizeIndexOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineLinearizeIndexOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineLinearizeIndexOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineLinearizeIndexOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineLinearizeIndexOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineLinearizeIndexOp::writeProperties, "writer"_a)
.def_prop_ro("disjoint", &mlir::affine::AffineLinearizeIndexOp::getDisjoint)
.def("set_disjoint", &mlir::affine::AffineLinearizeIndexOp::setDisjoint, "new_disjoint"_a)
.def_prop_ro("static_basis_attr", &mlir::affine::AffineLinearizeIndexOp::getStaticBasisAttr)
.def_prop_ro("static_basis", &mlir::affine::AffineLinearizeIndexOp::getStaticBasis)
.def("set_static_basis_attr", &mlir::affine::AffineLinearizeIndexOp::setStaticBasisAttr, "attr"_a)
.def("set_static_basis", &mlir::affine::AffineLinearizeIndexOp::setStaticBasis, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange multi_index, mlir::ValueRange basis, bool disjoint){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, multi_index, basis, disjoint); }, "ods_builder"_a, "ods_state"_a, "multi_index"_a, "basis"_a, "disjoint"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange multi_index, llvm::ArrayRef<mlir::OpFoldResult> basis, bool disjoint){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, multi_index, basis, disjoint); }, "ods_builder"_a, "ods_state"_a, "multi_index"_a, "basis"_a, "disjoint"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange multi_index, ArrayRef<int64_t> basis, bool disjoint){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, multi_index, basis, disjoint); }, "ods_builder"_a, "ods_state"_a, "multi_index"_a, "basis"_a, "disjoint"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type linear_index, mlir::ValueRange multi_index, mlir::ValueRange dynamic_basis, mlir::detail::DenseArrayAttrImpl<int64_t> static_basis, bool disjoint){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, linear_index, multi_index, dynamic_basis, static_basis, disjoint); }, "ods_builder"_a, "ods_state"_a, "linear_index"_a, "multi_index"_a, "dynamic_basis"_a, "static_basis"_a, "disjoint"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange multi_index, mlir::ValueRange dynamic_basis, mlir::detail::DenseArrayAttrImpl<int64_t> static_basis, bool disjoint){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, multi_index, dynamic_basis, static_basis, disjoint); }, "ods_builder"_a, "ods_state"_a, "multi_index"_a, "dynamic_basis"_a, "static_basis"_a, "disjoint"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange multi_index, mlir::ValueRange dynamic_basis, mlir::detail::DenseArrayAttrImpl<int64_t> static_basis, bool disjoint){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, resultTypes, multi_index, dynamic_basis, static_basis, disjoint); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "multi_index"_a, "dynamic_basis"_a, "static_basis"_a, "disjoint"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type linear_index, mlir::ValueRange multi_index, mlir::ValueRange dynamic_basis, ::llvm::ArrayRef<int64_t> static_basis, bool disjoint){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, linear_index, multi_index, dynamic_basis, static_basis, disjoint); }, "ods_builder"_a, "ods_state"_a, "linear_index"_a, "multi_index"_a, "dynamic_basis"_a, "static_basis"_a, "disjoint"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange multi_index, mlir::ValueRange dynamic_basis, ::llvm::ArrayRef<int64_t> static_basis, bool disjoint){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, multi_index, dynamic_basis, static_basis, disjoint); }, "ods_builder"_a, "ods_state"_a, "multi_index"_a, "dynamic_basis"_a, "static_basis"_a, "disjoint"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange multi_index, mlir::ValueRange dynamic_basis, ::llvm::ArrayRef<int64_t> static_basis, bool disjoint){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, resultTypes, multi_index, dynamic_basis, static_basis, disjoint); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "multi_index"_a, "dynamic_basis"_a, "static_basis"_a, "disjoint"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineLinearizeIndexOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineLinearizeIndexOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::affine::AffineLinearizeIndexOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineLinearizeIndexOp::verifyInvariants)
.def("verify", &mlir::affine::AffineLinearizeIndexOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineLinearizeIndexOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffineLinearizeIndexOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::affine::AffineLinearizeIndexOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def_static("parse", &mlir::affine::AffineLinearizeIndexOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::affine::AffineLinearizeIndexOp::getEffects, "effects"_a)
.def("has_outer_bound", &mlir::affine::AffineLinearizeIndexOp::hasOuterBound)
.def_prop_ro("mixed_basis", &mlir::affine::AffineLinearizeIndexOp::getMixedBasis)
.def_prop_ro("effective_basis", &mlir::affine::AffineLinearizeIndexOp::getEffectiveBasis)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineLinearizeIndexOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineLinearizeIndexOp>>(m, "TypeIDResolver[affine::AffineLinearizeIndexOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineLinearizeIndexOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineLoadOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineLoadOpGenericAdaptorBase>(m, "AffineLoadOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineLoadOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineLoadOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineLoadOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineLoadOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineLoadOpGenericAdaptorBase::getAttributes)
.def_prop_ro("map_attr", &mlir::affine::detail::AffineLoadOpGenericAdaptorBase::getMapAttr)
.def_prop_ro("map", &mlir::affine::detail::AffineLoadOpGenericAdaptorBase::getMap)
;

auto mlir_affine_detail_AffineLoadOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineLoadOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineLoadOpGenericAdaptorBase, "Properties")
.def_prop_ro("map", &mlir::affine::detail::AffineLoadOpGenericAdaptorBase::Properties::getMap)
.def("set_map", &mlir::affine::detail::AffineLoadOpGenericAdaptorBase::Properties::setMap, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineLoadOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineLoadOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineLoadOpAdaptor = nb::class_<mlir::affine::AffineLoadOpAdaptor>(m, "AffineLoadOpAdaptor")
.def(nb::init<mlir::affine::AffineLoadOp>(), "op"_a)
.def("verify", &mlir::affine::AffineLoadOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineLoadOp = nb::class_<mlir::affine::AffineLoadOp,  mlir::OpState>(m, "AffineLoadOp")
.def_static("attribute_names", &mlir::affine::AffineLoadOp::getAttributeNames)
.def_prop_ro("map_attr_name", [](mlir::affine::AffineLoadOp& self){ return self.getMapAttrName(); })
.def_static("get_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineLoadOp::getMapAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineLoadOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineLoadOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineLoadOp::getODSOperands, "index"_a)
.def_prop_ro("memref", &mlir::affine::AffineLoadOp::getMemref)
.def_prop_ro("indices", &mlir::affine::AffineLoadOp::getIndices)
.def_prop_ro("memref_mutable", &mlir::affine::AffineLoadOp::getMemrefMutable)
.def_prop_ro("indices_mutable", &mlir::affine::AffineLoadOp::getIndicesMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineLoadOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineLoadOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::affine::AffineLoadOp::getResult)
.def_static("set_properties_from_attr", &mlir::affine::AffineLoadOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineLoadOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineLoadOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineLoadOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineLoadOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineLoadOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineLoadOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineLoadOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineLoadOp::writeProperties, "writer"_a)
.def_prop_ro("map_attr", &mlir::affine::AffineLoadOp::getMapAttr)
.def_prop_ro("map", &mlir::affine::AffineLoadOp::getMap)
.def("set_map_attr", &mlir::affine::AffineLoadOp::setMapAttr, "attr"_a)
.def("set_map", &mlir::affine::AffineLoadOp::setMap, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::AffineMap map, mlir::ValueRange operands){ return mlir::affine::AffineLoadOp::build(odsBuilder, odsState, map, operands); }, "ods_builder"_a, "ods_state"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value memref, mlir::ValueRange indices){ return mlir::affine::AffineLoadOp::build(odsBuilder, odsState, memref, indices); }, "ods_builder"_a, "ods_state"_a, "memref"_a, "indices"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value memref, mlir::AffineMap map, mlir::ValueRange mapOperands){ return mlir::affine::AffineLoadOp::build(odsBuilder, odsState, memref, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "memref"_a, "map"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value memref, mlir::ValueRange indices, mlir::AffineMapAttr map){ return mlir::affine::AffineLoadOp::build(odsBuilder, odsState, result, memref, indices, map); }, "ods_builder"_a, "ods_state"_a, "result"_a, "memref"_a, "indices"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value memref, mlir::ValueRange indices, mlir::AffineMapAttr map){ return mlir::affine::AffineLoadOp::build(odsBuilder, odsState, resultTypes, memref, indices, map); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "memref"_a, "indices"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value memref, mlir::ValueRange indices, mlir::AffineMap map){ return mlir::affine::AffineLoadOp::build(odsBuilder, odsState, result, memref, indices, map); }, "ods_builder"_a, "ods_state"_a, "result"_a, "memref"_a, "indices"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value memref, mlir::ValueRange indices, mlir::AffineMap map){ return mlir::affine::AffineLoadOp::build(odsBuilder, odsState, resultTypes, memref, indices, map); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "memref"_a, "indices"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineLoadOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::affine::AffineLoadOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineLoadOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineLoadOp::verifyInvariants)
.def("verify", &mlir::affine::AffineLoadOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineLoadOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffineLoadOp::fold, "adaptor"_a)
.def("get_effects", &mlir::affine::AffineLoadOp::getEffects, "effects"_a)
.def_prop_ro("mem_ref_operand_index", &mlir::affine::AffineLoadOp::getMemRefOperandIndex)
.def("set_mem_ref", &mlir::affine::AffineLoadOp::setMemRef, "value"_a)
.def_prop_ro("affine_map_attr", &mlir::affine::AffineLoadOp::getAffineMapAttr)
.def_static("map_attr_str_name", &mlir::affine::AffineLoadOp::getMapAttrStrName)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineLoadOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineLoadOp>>(m, "TypeIDResolver[affine::AffineLoadOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineLoadOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineMaxOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineMaxOpGenericAdaptorBase>(m, "AffineMaxOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineMaxOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineMaxOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineMaxOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineMaxOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineMaxOpGenericAdaptorBase::getAttributes)
.def_prop_ro("map_attr", &mlir::affine::detail::AffineMaxOpGenericAdaptorBase::getMapAttr)
.def_prop_ro("map", &mlir::affine::detail::AffineMaxOpGenericAdaptorBase::getMap)
;

auto mlir_affine_detail_AffineMaxOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineMaxOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineMaxOpGenericAdaptorBase, "Properties")
.def_prop_ro("map", &mlir::affine::detail::AffineMaxOpGenericAdaptorBase::Properties::getMap)
.def("set_map", &mlir::affine::detail::AffineMaxOpGenericAdaptorBase::Properties::setMap, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineMaxOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineMaxOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineMaxOpAdaptor = nb::class_<mlir::affine::AffineMaxOpAdaptor>(m, "AffineMaxOpAdaptor")
.def(nb::init<mlir::affine::AffineMaxOp>(), "op"_a)
.def("verify", &mlir::affine::AffineMaxOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineMaxOp = nb::class_<mlir::affine::AffineMaxOp,  mlir::OpState>(m, "AffineMaxOp")
.def_static("attribute_names", &mlir::affine::AffineMaxOp::getAttributeNames)
.def_prop_ro("map_attr_name", [](mlir::affine::AffineMaxOp& self){ return self.getMapAttrName(); })
.def_static("get_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineMaxOp::getMapAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineMaxOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineMaxOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineMaxOp::getODSOperands, "index"_a)
.def_prop_ro("operands", &mlir::affine::AffineMaxOp::getOperands)
.def_prop_ro("operands_mutable", &mlir::affine::AffineMaxOp::getOperandsMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineMaxOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineMaxOp::getODSResults, "index"_a)
.def_static("set_properties_from_attr", &mlir::affine::AffineMaxOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineMaxOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineMaxOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineMaxOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineMaxOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineMaxOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineMaxOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineMaxOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineMaxOp::writeProperties, "writer"_a)
.def_prop_ro("map_attr", &mlir::affine::AffineMaxOp::getMapAttr)
.def_prop_ro("map", &mlir::affine::AffineMaxOp::getMap)
.def("set_map_attr", &mlir::affine::AffineMaxOp::setMapAttr, "attr"_a)
.def("set_map", &mlir::affine::AffineMaxOp::setMap, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type resultType0, mlir::AffineMapAttr map, mlir::ValueRange operands){ return mlir::affine::AffineMaxOp::build(odsBuilder, odsState, resultType0, map, operands); }, "ods_builder"_a, "ods_state"_a, "result_type0"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::AffineMapAttr map, mlir::ValueRange operands){ return mlir::affine::AffineMaxOp::build(odsBuilder, odsState, map, operands); }, "ods_builder"_a, "ods_state"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::AffineMapAttr map, mlir::ValueRange operands){ return mlir::affine::AffineMaxOp::build(odsBuilder, odsState, resultTypes, map, operands); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type resultType0, mlir::AffineMap map, mlir::ValueRange operands){ return mlir::affine::AffineMaxOp::build(odsBuilder, odsState, resultType0, map, operands); }, "ods_builder"_a, "ods_state"_a, "result_type0"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::AffineMap map, mlir::ValueRange operands){ return mlir::affine::AffineMaxOp::build(odsBuilder, odsState, map, operands); }, "ods_builder"_a, "ods_state"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::AffineMap map, mlir::ValueRange operands){ return mlir::affine::AffineMaxOp::build(odsBuilder, odsState, resultTypes, map, operands); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineMaxOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineMaxOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::affine::AffineMaxOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineMaxOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineMaxOp::verifyInvariants)
.def("verify", &mlir::affine::AffineMaxOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineMaxOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffineMaxOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::affine::AffineMaxOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("get_effects", &mlir::affine::AffineMaxOp::getEffects, "effects"_a)
.def_static("map_attr_str_name", &mlir::affine::AffineMaxOp::getMapAttrStrName)
.def_prop_ro("affine_map", &mlir::affine::AffineMaxOp::getAffineMap)
.def_prop_ro("map_operands", &mlir::affine::AffineMaxOp::getMapOperands)
.def_prop_ro("dim_operands", &mlir::affine::AffineMaxOp::getDimOperands)
.def_prop_ro("symbol_operands", &mlir::affine::AffineMaxOp::getSymbolOperands)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineMaxOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineMaxOp>>(m, "TypeIDResolver[affine::AffineMaxOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineMaxOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineMinOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineMinOpGenericAdaptorBase>(m, "AffineMinOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineMinOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineMinOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineMinOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineMinOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineMinOpGenericAdaptorBase::getAttributes)
.def_prop_ro("map_attr", &mlir::affine::detail::AffineMinOpGenericAdaptorBase::getMapAttr)
.def_prop_ro("map", &mlir::affine::detail::AffineMinOpGenericAdaptorBase::getMap)
;

auto mlir_affine_detail_AffineMinOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineMinOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineMinOpGenericAdaptorBase, "Properties")
.def_prop_ro("map", &mlir::affine::detail::AffineMinOpGenericAdaptorBase::Properties::getMap)
.def("set_map", &mlir::affine::detail::AffineMinOpGenericAdaptorBase::Properties::setMap, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineMinOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineMinOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineMinOpAdaptor = nb::class_<mlir::affine::AffineMinOpAdaptor>(m, "AffineMinOpAdaptor")
.def(nb::init<mlir::affine::AffineMinOp>(), "op"_a)
.def("verify", &mlir::affine::AffineMinOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineMinOp = nb::class_<mlir::affine::AffineMinOp,  mlir::OpState>(m, "AffineMinOp")
.def_static("attribute_names", &mlir::affine::AffineMinOp::getAttributeNames)
.def_prop_ro("map_attr_name", [](mlir::affine::AffineMinOp& self){ return self.getMapAttrName(); })
.def_static("get_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineMinOp::getMapAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineMinOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineMinOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineMinOp::getODSOperands, "index"_a)
.def_prop_ro("operands", &mlir::affine::AffineMinOp::getOperands)
.def_prop_ro("operands_mutable", &mlir::affine::AffineMinOp::getOperandsMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineMinOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineMinOp::getODSResults, "index"_a)
.def_static("set_properties_from_attr", &mlir::affine::AffineMinOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineMinOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineMinOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineMinOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineMinOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineMinOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineMinOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineMinOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineMinOp::writeProperties, "writer"_a)
.def_prop_ro("map_attr", &mlir::affine::AffineMinOp::getMapAttr)
.def_prop_ro("map", &mlir::affine::AffineMinOp::getMap)
.def("set_map_attr", &mlir::affine::AffineMinOp::setMapAttr, "attr"_a)
.def("set_map", &mlir::affine::AffineMinOp::setMap, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type resultType0, mlir::AffineMapAttr map, mlir::ValueRange operands){ return mlir::affine::AffineMinOp::build(odsBuilder, odsState, resultType0, map, operands); }, "ods_builder"_a, "ods_state"_a, "result_type0"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::AffineMapAttr map, mlir::ValueRange operands){ return mlir::affine::AffineMinOp::build(odsBuilder, odsState, map, operands); }, "ods_builder"_a, "ods_state"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::AffineMapAttr map, mlir::ValueRange operands){ return mlir::affine::AffineMinOp::build(odsBuilder, odsState, resultTypes, map, operands); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type resultType0, mlir::AffineMap map, mlir::ValueRange operands){ return mlir::affine::AffineMinOp::build(odsBuilder, odsState, resultType0, map, operands); }, "ods_builder"_a, "ods_state"_a, "result_type0"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::AffineMap map, mlir::ValueRange operands){ return mlir::affine::AffineMinOp::build(odsBuilder, odsState, map, operands); }, "ods_builder"_a, "ods_state"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::AffineMap map, mlir::ValueRange operands){ return mlir::affine::AffineMinOp::build(odsBuilder, odsState, resultTypes, map, operands); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineMinOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineMinOp::build(odsBuilder, odsState, operands, attributes); }, "ods_builder"_a, "ods_state"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::affine::AffineMinOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineMinOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineMinOp::verifyInvariants)
.def("verify", &mlir::affine::AffineMinOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineMinOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffineMinOp::fold, "adaptor"_a)
.def_static("infer_return_types", &mlir::affine::AffineMinOp::inferReturnTypes, "context"_a, "location"_a, "operands"_a, "attributes"_a, "properties"_a, "regions"_a, "inferred_return_types"_a)
.def("get_effects", &mlir::affine::AffineMinOp::getEffects, "effects"_a)
.def_static("map_attr_str_name", &mlir::affine::AffineMinOp::getMapAttrStrName)
.def_prop_ro("affine_map", &mlir::affine::AffineMinOp::getAffineMap)
.def_prop_ro("map_operands", &mlir::affine::AffineMinOp::getMapOperands)
.def_prop_ro("dim_operands", &mlir::affine::AffineMinOp::getDimOperands)
.def_prop_ro("symbol_operands", &mlir::affine::AffineMinOp::getSymbolOperands)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineMinOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineMinOp>>(m, "TypeIDResolver[affine::AffineMinOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineMinOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineParallelOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineParallelOpGenericAdaptorBase>(m, "AffineParallelOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineParallelOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getAttributes)
.def_prop_ro("reductions_attr", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getReductionsAttr)
.def_prop_ro("reductions", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getReductions)
.def_prop_ro("lower_bounds_map_attr", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getLowerBoundsMapAttr)
.def_prop_ro("lower_bounds_map", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getLowerBoundsMap)
.def_prop_ro("lower_bounds_groups_attr", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getLowerBoundsGroupsAttr)
.def_prop_ro("lower_bounds_groups", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getLowerBoundsGroups)
.def_prop_ro("upper_bounds_map_attr", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getUpperBoundsMapAttr)
.def_prop_ro("upper_bounds_map", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getUpperBoundsMap)
.def_prop_ro("upper_bounds_groups_attr", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getUpperBoundsGroupsAttr)
.def_prop_ro("upper_bounds_groups", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getUpperBoundsGroups)
.def_prop_ro("steps_attr", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getStepsAttr)
.def_prop_ro("steps", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getSteps)
.def_prop_ro("region", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getRegion)
.def_prop_ro("regions", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::getRegions)
;

auto mlir_affine_detail_AffineParallelOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineParallelOpGenericAdaptorBase, "Properties")
.def_prop_ro("lower_bounds_groups", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::getLowerBoundsGroups)
.def("set_lower_bounds_groups", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::setLowerBoundsGroups, "prop_value"_a)
.def_prop_ro("lower_bounds_map", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::getLowerBoundsMap)
.def("set_lower_bounds_map", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::setLowerBoundsMap, "prop_value"_a)
.def_prop_ro("reductions", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::getReductions)
.def("set_reductions", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::setReductions, "prop_value"_a)
.def_prop_ro("steps", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::getSteps)
.def("set_steps", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::setSteps, "prop_value"_a)
.def_prop_ro("upper_bounds_groups", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::getUpperBoundsGroups)
.def("set_upper_bounds_groups", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::setUpperBoundsGroups, "prop_value"_a)
.def_prop_ro("upper_bounds_map", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::getUpperBoundsMap)
.def("set_upper_bounds_map", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::setUpperBoundsMap, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineParallelOpAdaptor = nb::class_<mlir::affine::AffineParallelOpAdaptor>(m, "AffineParallelOpAdaptor")
.def(nb::init<mlir::affine::AffineParallelOp>(), "op"_a)
.def("verify", &mlir::affine::AffineParallelOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineParallelOp = nb::class_<mlir::affine::AffineParallelOp,  mlir::OpState>(m, "AffineParallelOp")
.def_static("attribute_names", &mlir::affine::AffineParallelOp::getAttributeNames)
.def_prop_ro("lower_bounds_groups_attr_name", [](mlir::affine::AffineParallelOp& self){ return self.getLowerBoundsGroupsAttrName(); })
.def_static("get_lower_bounds_groups_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineParallelOp::getLowerBoundsGroupsAttrName(name); }, "name"_a)
.def_prop_ro("lower_bounds_map_attr_name", [](mlir::affine::AffineParallelOp& self){ return self.getLowerBoundsMapAttrName(); })
.def_static("get_lower_bounds_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineParallelOp::getLowerBoundsMapAttrName(name); }, "name"_a)
.def_prop_ro("reductions_attr_name", [](mlir::affine::AffineParallelOp& self){ return self.getReductionsAttrName(); })
.def_static("get_reductions_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineParallelOp::getReductionsAttrName(name); }, "name"_a)
.def_prop_ro("steps_attr_name", [](mlir::affine::AffineParallelOp& self){ return self.getStepsAttrName(); })
.def_static("get_steps_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineParallelOp::getStepsAttrName(name); }, "name"_a)
.def_prop_ro("upper_bounds_groups_attr_name", [](mlir::affine::AffineParallelOp& self){ return self.getUpperBoundsGroupsAttrName(); })
.def_static("get_upper_bounds_groups_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineParallelOp::getUpperBoundsGroupsAttrName(name); }, "name"_a)
.def_prop_ro("upper_bounds_map_attr_name", [](mlir::affine::AffineParallelOp& self){ return self.getUpperBoundsMapAttrName(); })
.def_static("get_upper_bounds_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineParallelOp::getUpperBoundsMapAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineParallelOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineParallelOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineParallelOp::getODSOperands, "index"_a)
.def_prop_ro("map_operands", &mlir::affine::AffineParallelOp::getMapOperands)
.def_prop_ro("map_operands_mutable", &mlir::affine::AffineParallelOp::getMapOperandsMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineParallelOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineParallelOp::getODSResults, "index"_a)
.def_prop_ro("results", &mlir::affine::AffineParallelOp::getResults)
.def_prop_ro("region", &mlir::affine::AffineParallelOp::getRegion)
.def_static("set_properties_from_attr", &mlir::affine::AffineParallelOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineParallelOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineParallelOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineParallelOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineParallelOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineParallelOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineParallelOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineParallelOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineParallelOp::writeProperties, "writer"_a)
.def_prop_ro("reductions_attr", &mlir::affine::AffineParallelOp::getReductionsAttr)
.def_prop_ro("reductions", &mlir::affine::AffineParallelOp::getReductions)
.def_prop_ro("lower_bounds_map_attr", &mlir::affine::AffineParallelOp::getLowerBoundsMapAttr)
.def_prop_ro("lower_bounds_map", &mlir::affine::AffineParallelOp::getLowerBoundsMap)
.def_prop_ro("lower_bounds_groups_attr", &mlir::affine::AffineParallelOp::getLowerBoundsGroupsAttr)
.def_prop_ro("lower_bounds_groups", &mlir::affine::AffineParallelOp::getLowerBoundsGroups)
.def_prop_ro("upper_bounds_map_attr", &mlir::affine::AffineParallelOp::getUpperBoundsMapAttr)
.def_prop_ro("upper_bounds_map", &mlir::affine::AffineParallelOp::getUpperBoundsMap)
.def_prop_ro("upper_bounds_groups_attr", &mlir::affine::AffineParallelOp::getUpperBoundsGroupsAttr)
.def_prop_ro("upper_bounds_groups", &mlir::affine::AffineParallelOp::getUpperBoundsGroups)
.def_prop_ro("steps_attr", &mlir::affine::AffineParallelOp::getStepsAttr)
.def_prop_ro("steps", &mlir::affine::AffineParallelOp::getSteps)
.def("set_reductions_attr", &mlir::affine::AffineParallelOp::setReductionsAttr, "attr"_a)
.def("set_lower_bounds_map_attr", &mlir::affine::AffineParallelOp::setLowerBoundsMapAttr, "attr"_a)
.def("set_lower_bounds_map", &mlir::affine::AffineParallelOp::setLowerBoundsMap, "attr_value"_a)
.def("set_lower_bounds_groups_attr", &mlir::affine::AffineParallelOp::setLowerBoundsGroupsAttr, "attr"_a)
.def("set_upper_bounds_map_attr", &mlir::affine::AffineParallelOp::setUpperBoundsMapAttr, "attr"_a)
.def("set_upper_bounds_map", &mlir::affine::AffineParallelOp::setUpperBoundsMap, "attr_value"_a)
.def("set_upper_bounds_groups_attr", &mlir::affine::AffineParallelOp::setUpperBoundsGroupsAttr, "attr"_a)
.def("set_steps_attr", &mlir::affine::AffineParallelOp::setStepsAttr, "attr"_a)
.def("set_steps", [](mlir::affine::AffineParallelOp& self, ::llvm::SmallVector<int64_t, 8> attrValue){ return self.setSteps(attrValue); }, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, llvm::ArrayRef<mlir::arith::AtomicRMWKind> reductions, ArrayRef<int64_t> ranges){ return mlir::affine::AffineParallelOp::build(odsBuilder, odsState, resultTypes, reductions, ranges); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "reductions"_a, "ranges"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, llvm::ArrayRef<mlir::arith::AtomicRMWKind> reductions, llvm::ArrayRef<mlir::AffineMap> lbMaps, mlir::ValueRange lbArgs, llvm::ArrayRef<mlir::AffineMap> ubMaps, mlir::ValueRange ubArgs, ArrayRef<int64_t> steps){ return mlir::affine::AffineParallelOp::build(odsBuilder, odsState, resultTypes, reductions, lbMaps, lbArgs, ubMaps, ubArgs, steps); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "reductions"_a, "lb_maps"_a, "lb_args"_a, "ub_maps"_a, "ub_args"_a, "steps"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange results, mlir::ArrayAttr reductions, mlir::AffineMapAttr lowerBoundsMap, mlir::DenseIntElementsAttr lowerBoundsGroups, mlir::AffineMapAttr upperBoundsMap, mlir::DenseIntElementsAttr upperBoundsGroups, mlir::ArrayAttr steps, mlir::ValueRange mapOperands){ return mlir::affine::AffineParallelOp::build(odsBuilder, odsState, results, reductions, lowerBoundsMap, lowerBoundsGroups, upperBoundsMap, upperBoundsGroups, steps, mapOperands); }, "ods_builder"_a, "ods_state"_a, "results"_a, "reductions"_a, "lower_bounds_map"_a, "lower_bounds_groups"_a, "upper_bounds_map"_a, "upper_bounds_groups"_a, "steps"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange results, mlir::ArrayAttr reductions, mlir::AffineMap lowerBoundsMap, mlir::DenseIntElementsAttr lowerBoundsGroups, mlir::AffineMap upperBoundsMap, mlir::DenseIntElementsAttr upperBoundsGroups, ::llvm::SmallVector<int64_t, 8> steps, mlir::ValueRange mapOperands){ return mlir::affine::AffineParallelOp::build(odsBuilder, odsState, results, reductions, lowerBoundsMap, lowerBoundsGroups, upperBoundsMap, upperBoundsGroups, steps, mapOperands); }, "ods_builder"_a, "ods_state"_a, "results"_a, "reductions"_a, "lower_bounds_map"_a, "lower_bounds_groups"_a, "upper_bounds_map"_a, "upper_bounds_groups"_a, "steps"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineParallelOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::affine::AffineParallelOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineParallelOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineParallelOp::verifyInvariants)
.def("verify", &mlir::affine::AffineParallelOp::verify)
.def("fold", &mlir::affine::AffineParallelOp::fold, "adaptor"_a, "results"_a)
.def_prop_ro("loop_regions", &mlir::affine::AffineParallelOp::getLoopRegions)
.def_prop_ro("num_dims", &mlir::affine::AffineParallelOp::getNumDims)
.def_prop_ro("constant_ranges", &mlir::affine::AffineParallelOp::getConstantRanges)
.def_prop_ro("body", &mlir::affine::AffineParallelOp::getBody)
.def_prop_ro("body_builder", &mlir::affine::AffineParallelOp::getBodyBuilder)
.def_prop_ro("i_vs", &mlir::affine::AffineParallelOp::getIVs)
.def("get_lower_bound_map", &mlir::affine::AffineParallelOp::getLowerBoundMap, "pos"_a)
.def_prop_ro("lower_bounds_operands", &mlir::affine::AffineParallelOp::getLowerBoundsOperands)
.def_prop_ro("lower_bounds_value_map", &mlir::affine::AffineParallelOp::getLowerBoundsValueMap)
.def("set_lower_bounds", &mlir::affine::AffineParallelOp::setLowerBounds, "operands"_a, "map"_a)
.def("get_upper_bound_map", &mlir::affine::AffineParallelOp::getUpperBoundMap, "pos"_a)
.def_prop_ro("upper_bounds_operands", &mlir::affine::AffineParallelOp::getUpperBoundsOperands)
.def_prop_ro("upper_bounds_value_map", &mlir::affine::AffineParallelOp::getUpperBoundsValueMap)
.def("set_upper_bounds", &mlir::affine::AffineParallelOp::setUpperBounds, "operands"_a, "map"_a)
.def("set_steps", [](mlir::affine::AffineParallelOp& self, ArrayRef<int64_t> newSteps){ return self.setSteps(newSteps); }, "new_steps"_a)
.def_static("reductions_attr_str_name", &mlir::affine::AffineParallelOp::getReductionsAttrStrName)
.def_static("lower_bounds_map_attr_str_name", &mlir::affine::AffineParallelOp::getLowerBoundsMapAttrStrName)
.def_static("lower_bounds_groups_attr_str_name", &mlir::affine::AffineParallelOp::getLowerBoundsGroupsAttrStrName)
.def_static("upper_bounds_map_attr_str_name", &mlir::affine::AffineParallelOp::getUpperBoundsMapAttrStrName)
.def_static("upper_bounds_groups_attr_str_name", &mlir::affine::AffineParallelOp::getUpperBoundsGroupsAttrStrName)
.def_static("steps_attr_str_name", &mlir::affine::AffineParallelOp::getStepsAttrStrName)
.def("has_min_max_bounds", &mlir::affine::AffineParallelOp::hasMinMaxBounds)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineParallelOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineParallelOp>>(m, "TypeIDResolver[affine::AffineParallelOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineParallelOp>::resolveTypeID)
;

auto mlir_affine_detail_AffinePrefetchOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase>(m, "AffinePrefetchOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffinePrefetchOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getAttributes)
.def_prop_ro("is_write_attr", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getIsWriteAttr)
.def_prop_ro("is_write", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getIsWrite)
.def_prop_ro("locality_hint_attr", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getLocalityHintAttr)
.def_prop_ro("locality_hint", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getLocalityHint)
.def_prop_ro("is_data_cache_attr", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getIsDataCacheAttr)
.def_prop_ro("is_data_cache", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getIsDataCache)
.def_prop_ro("map_attr", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getMapAttr)
.def_prop_ro("map", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::getMap)
;

auto mlir_affine_detail_AffinePrefetchOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffinePrefetchOpGenericAdaptorBase, "Properties")
.def_prop_ro("is_data_cache", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::getIsDataCache)
.def("set_is_data_cache", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::setIsDataCache, "prop_value"_a)
.def_prop_ro("is_write", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::getIsWrite)
.def("set_is_write", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::setIsWrite, "prop_value"_a)
.def_prop_ro("locality_hint", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::getLocalityHint)
.def("set_locality_hint", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::setLocalityHint, "prop_value"_a)
.def_prop_ro("map", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::getMap)
.def("set_map", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::setMap, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffinePrefetchOpAdaptor = nb::class_<mlir::affine::AffinePrefetchOpAdaptor>(m, "AffinePrefetchOpAdaptor")
.def(nb::init<mlir::affine::AffinePrefetchOp>(), "op"_a)
.def("verify", &mlir::affine::AffinePrefetchOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffinePrefetchOp = nb::class_<mlir::affine::AffinePrefetchOp,  mlir::OpState>(m, "AffinePrefetchOp")
.def_static("attribute_names", &mlir::affine::AffinePrefetchOp::getAttributeNames)
.def_prop_ro("is_data_cache_attr_name", [](mlir::affine::AffinePrefetchOp& self){ return self.getIsDataCacheAttrName(); })
.def_static("get_is_data_cache_attr_name", [](mlir::OperationName name){ return mlir::affine::AffinePrefetchOp::getIsDataCacheAttrName(name); }, "name"_a)
.def_prop_ro("is_write_attr_name", [](mlir::affine::AffinePrefetchOp& self){ return self.getIsWriteAttrName(); })
.def_static("get_is_write_attr_name", [](mlir::OperationName name){ return mlir::affine::AffinePrefetchOp::getIsWriteAttrName(name); }, "name"_a)
.def_prop_ro("locality_hint_attr_name", [](mlir::affine::AffinePrefetchOp& self){ return self.getLocalityHintAttrName(); })
.def_static("get_locality_hint_attr_name", [](mlir::OperationName name){ return mlir::affine::AffinePrefetchOp::getLocalityHintAttrName(name); }, "name"_a)
.def_prop_ro("map_attr_name", [](mlir::affine::AffinePrefetchOp& self){ return self.getMapAttrName(); })
.def_static("get_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffinePrefetchOp::getMapAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffinePrefetchOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffinePrefetchOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffinePrefetchOp::getODSOperands, "index"_a)
.def_prop_ro("memref", &mlir::affine::AffinePrefetchOp::getMemref)
.def_prop_ro("indices", &mlir::affine::AffinePrefetchOp::getIndices)
.def_prop_ro("memref_mutable", &mlir::affine::AffinePrefetchOp::getMemrefMutable)
.def_prop_ro("indices_mutable", &mlir::affine::AffinePrefetchOp::getIndicesMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffinePrefetchOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffinePrefetchOp::getODSResults, "index"_a)
.def_static("set_properties_from_attr", &mlir::affine::AffinePrefetchOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffinePrefetchOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffinePrefetchOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffinePrefetchOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffinePrefetchOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffinePrefetchOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffinePrefetchOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffinePrefetchOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffinePrefetchOp::writeProperties, "writer"_a)
.def_prop_ro("is_write_attr", &mlir::affine::AffinePrefetchOp::getIsWriteAttr)
.def_prop_ro("is_write", &mlir::affine::AffinePrefetchOp::getIsWrite)
.def_prop_ro("locality_hint_attr", &mlir::affine::AffinePrefetchOp::getLocalityHintAttr)
.def_prop_ro("locality_hint", &mlir::affine::AffinePrefetchOp::getLocalityHint)
.def_prop_ro("is_data_cache_attr", &mlir::affine::AffinePrefetchOp::getIsDataCacheAttr)
.def_prop_ro("is_data_cache", &mlir::affine::AffinePrefetchOp::getIsDataCache)
.def_prop_ro("map_attr", &mlir::affine::AffinePrefetchOp::getMapAttr)
.def_prop_ro("map", &mlir::affine::AffinePrefetchOp::getMap)
.def("set_is_write_attr", &mlir::affine::AffinePrefetchOp::setIsWriteAttr, "attr"_a)
.def("set_is_write", &mlir::affine::AffinePrefetchOp::setIsWrite, "attr_value"_a)
.def("set_locality_hint_attr", &mlir::affine::AffinePrefetchOp::setLocalityHintAttr, "attr"_a)
.def("set_locality_hint", &mlir::affine::AffinePrefetchOp::setLocalityHint, "attr_value"_a)
.def("set_is_data_cache_attr", &mlir::affine::AffinePrefetchOp::setIsDataCacheAttr, "attr"_a)
.def("set_is_data_cache", &mlir::affine::AffinePrefetchOp::setIsDataCache, "attr_value"_a)
.def("set_map_attr", &mlir::affine::AffinePrefetchOp::setMapAttr, "attr"_a)
.def("set_map", &mlir::affine::AffinePrefetchOp::setMap, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value memref, mlir::AffineMap map, llvm::ArrayRef<mlir::Value> mapOperands, bool isWrite, unsigned int localityHint, bool isDataCache){ return mlir::affine::AffinePrefetchOp::build(odsBuilder, odsState, memref, map, mapOperands, isWrite, localityHint, isDataCache); }, "ods_builder"_a, "ods_state"_a, "memref"_a, "map"_a, "map_operands"_a, "is_write"_a, "locality_hint"_a, "is_data_cache"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value memref, mlir::ValueRange indices, mlir::BoolAttr isWrite, mlir::IntegerAttr localityHint, mlir::BoolAttr isDataCache, mlir::AffineMapAttr map){ return mlir::affine::AffinePrefetchOp::build(odsBuilder, odsState, memref, indices, isWrite, localityHint, isDataCache, map); }, "ods_builder"_a, "ods_state"_a, "memref"_a, "indices"_a, "is_write"_a, "locality_hint"_a, "is_data_cache"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value memref, mlir::ValueRange indices, mlir::BoolAttr isWrite, mlir::IntegerAttr localityHint, mlir::BoolAttr isDataCache, mlir::AffineMapAttr map){ return mlir::affine::AffinePrefetchOp::build(odsBuilder, odsState, resultTypes, memref, indices, isWrite, localityHint, isDataCache, map); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "memref"_a, "indices"_a, "is_write"_a, "locality_hint"_a, "is_data_cache"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value memref, mlir::ValueRange indices, bool isWrite, uint32_t localityHint, bool isDataCache, mlir::AffineMap map){ return mlir::affine::AffinePrefetchOp::build(odsBuilder, odsState, memref, indices, isWrite, localityHint, isDataCache, map); }, "ods_builder"_a, "ods_state"_a, "memref"_a, "indices"_a, "is_write"_a, "locality_hint"_a, "is_data_cache"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value memref, mlir::ValueRange indices, bool isWrite, uint32_t localityHint, bool isDataCache, mlir::AffineMap map){ return mlir::affine::AffinePrefetchOp::build(odsBuilder, odsState, resultTypes, memref, indices, isWrite, localityHint, isDataCache, map); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "memref"_a, "indices"_a, "is_write"_a, "locality_hint"_a, "is_data_cache"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffinePrefetchOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::affine::AffinePrefetchOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffinePrefetchOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffinePrefetchOp::verifyInvariants)
.def("verify", &mlir::affine::AffinePrefetchOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffinePrefetchOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffinePrefetchOp::fold, "adaptor"_a, "results"_a)
.def_prop_ro("mem_ref_type", &mlir::affine::AffinePrefetchOp::getMemRefType)
.def_prop_ro("affine_map", &mlir::affine::AffinePrefetchOp::getAffineMap)
.def_prop_ro("affine_map_attr", &mlir::affine::AffinePrefetchOp::getAffineMapAttr)
.def("get_affine_map_attr_for_mem_ref", &mlir::affine::AffinePrefetchOp::getAffineMapAttrForMemRef, "mref"_a)
.def_prop_ro("map_operands", &mlir::affine::AffinePrefetchOp::getMapOperands)
.def_static("map_attr_str_name", &mlir::affine::AffinePrefetchOp::getMapAttrStrName)
.def_static("locality_hint_attr_str_name", &mlir::affine::AffinePrefetchOp::getLocalityHintAttrStrName)
.def_static("is_write_attr_str_name", &mlir::affine::AffinePrefetchOp::getIsWriteAttrStrName)
.def_static("is_data_cache_attr_str_name", &mlir::affine::AffinePrefetchOp::getIsDataCacheAttrStrName)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffinePrefetchOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffinePrefetchOp>>(m, "TypeIDResolver[affine::AffinePrefetchOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffinePrefetchOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineStoreOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineStoreOpGenericAdaptorBase>(m, "AffineStoreOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineStoreOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineStoreOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineStoreOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineStoreOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineStoreOpGenericAdaptorBase::getAttributes)
.def_prop_ro("map_attr", &mlir::affine::detail::AffineStoreOpGenericAdaptorBase::getMapAttr)
.def_prop_ro("map", &mlir::affine::detail::AffineStoreOpGenericAdaptorBase::getMap)
;

auto mlir_affine_detail_AffineStoreOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineStoreOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineStoreOpGenericAdaptorBase, "Properties")
.def_prop_ro("map", &mlir::affine::detail::AffineStoreOpGenericAdaptorBase::Properties::getMap)
.def("set_map", &mlir::affine::detail::AffineStoreOpGenericAdaptorBase::Properties::setMap, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineStoreOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineStoreOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineStoreOpAdaptor = nb::class_<mlir::affine::AffineStoreOpAdaptor>(m, "AffineStoreOpAdaptor")
.def(nb::init<mlir::affine::AffineStoreOp>(), "op"_a)
.def("verify", &mlir::affine::AffineStoreOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineStoreOp = nb::class_<mlir::affine::AffineStoreOp,  mlir::OpState>(m, "AffineStoreOp")
.def_static("attribute_names", &mlir::affine::AffineStoreOp::getAttributeNames)
.def_prop_ro("map_attr_name", [](mlir::affine::AffineStoreOp& self){ return self.getMapAttrName(); })
.def_static("get_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineStoreOp::getMapAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineStoreOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineStoreOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineStoreOp::getODSOperands, "index"_a)
.def_prop_ro("value", &mlir::affine::AffineStoreOp::getValue)
.def_prop_ro("memref", &mlir::affine::AffineStoreOp::getMemref)
.def_prop_ro("indices", &mlir::affine::AffineStoreOp::getIndices)
.def_prop_ro("value_mutable", &mlir::affine::AffineStoreOp::getValueMutable)
.def_prop_ro("memref_mutable", &mlir::affine::AffineStoreOp::getMemrefMutable)
.def_prop_ro("indices_mutable", &mlir::affine::AffineStoreOp::getIndicesMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineStoreOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineStoreOp::getODSResults, "index"_a)
.def_static("set_properties_from_attr", &mlir::affine::AffineStoreOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineStoreOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineStoreOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineStoreOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineStoreOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineStoreOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineStoreOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineStoreOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineStoreOp::writeProperties, "writer"_a)
.def_prop_ro("map_attr", &mlir::affine::AffineStoreOp::getMapAttr)
.def_prop_ro("map", &mlir::affine::AffineStoreOp::getMap)
.def("set_map_attr", &mlir::affine::AffineStoreOp::setMapAttr, "attr"_a)
.def("set_map", &mlir::affine::AffineStoreOp::setMap, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value valueToStore, mlir::Value memref, mlir::ValueRange indices){ return mlir::affine::AffineStoreOp::build(odsBuilder, odsState, valueToStore, memref, indices); }, "ods_builder"_a, "ods_state"_a, "value_to_store"_a, "memref"_a, "indices"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value valueToStore, mlir::Value memref, mlir::AffineMap map, mlir::ValueRange mapOperands){ return mlir::affine::AffineStoreOp::build(odsBuilder, odsState, valueToStore, memref, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "value_to_store"_a, "memref"_a, "map"_a, "map_operands"_a)
.def_static("parse", &mlir::affine::AffineStoreOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineStoreOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineStoreOp::verifyInvariants)
.def("verify", &mlir::affine::AffineStoreOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineStoreOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("fold", &mlir::affine::AffineStoreOp::fold, "adaptor"_a, "results"_a)
.def("get_effects", &mlir::affine::AffineStoreOp::getEffects, "effects"_a)
.def_prop_ro("stored_val_operand_index", &mlir::affine::AffineStoreOp::getStoredValOperandIndex)
.def_prop_ro("mem_ref_operand_index", &mlir::affine::AffineStoreOp::getMemRefOperandIndex)
.def("set_mem_ref", &mlir::affine::AffineStoreOp::setMemRef, "value"_a)
.def_prop_ro("affine_map_attr", &mlir::affine::AffineStoreOp::getAffineMapAttr)
.def_static("map_attr_str_name", &mlir::affine::AffineStoreOp::getMapAttrStrName)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineStoreOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineStoreOp>>(m, "TypeIDResolver[affine::AffineStoreOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineStoreOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineVectorLoadOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase>(m, "AffineVectorLoadOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineVectorLoadOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::getAttributes)
.def_prop_ro("map_attr", &mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::getMapAttr)
.def_prop_ro("map", &mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::getMap)
;

auto mlir_affine_detail_AffineVectorLoadOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineVectorLoadOpGenericAdaptorBase, "Properties")
.def_prop_ro("map", &mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::Properties::getMap)
.def("set_map", &mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::Properties::setMap, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineVectorLoadOpAdaptor = nb::class_<mlir::affine::AffineVectorLoadOpAdaptor>(m, "AffineVectorLoadOpAdaptor")
.def(nb::init<mlir::affine::AffineVectorLoadOp>(), "op"_a)
.def("verify", &mlir::affine::AffineVectorLoadOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineVectorLoadOp = nb::class_<mlir::affine::AffineVectorLoadOp,  mlir::OpState>(m, "AffineVectorLoadOp")
.def_static("attribute_names", &mlir::affine::AffineVectorLoadOp::getAttributeNames)
.def_prop_ro("map_attr_name", [](mlir::affine::AffineVectorLoadOp& self){ return self.getMapAttrName(); })
.def_static("get_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineVectorLoadOp::getMapAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineVectorLoadOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineVectorLoadOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineVectorLoadOp::getODSOperands, "index"_a)
.def_prop_ro("memref", &mlir::affine::AffineVectorLoadOp::getMemref)
.def_prop_ro("indices", &mlir::affine::AffineVectorLoadOp::getIndices)
.def_prop_ro("memref_mutable", &mlir::affine::AffineVectorLoadOp::getMemrefMutable)
.def_prop_ro("indices_mutable", &mlir::affine::AffineVectorLoadOp::getIndicesMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineVectorLoadOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineVectorLoadOp::getODSResults, "index"_a)
.def_prop_ro("result", &mlir::affine::AffineVectorLoadOp::getResult)
.def_static("set_properties_from_attr", &mlir::affine::AffineVectorLoadOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineVectorLoadOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineVectorLoadOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineVectorLoadOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineVectorLoadOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineVectorLoadOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineVectorLoadOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineVectorLoadOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineVectorLoadOp::writeProperties, "writer"_a)
.def_prop_ro("map_attr", &mlir::affine::AffineVectorLoadOp::getMapAttr)
.def_prop_ro("map", &mlir::affine::AffineVectorLoadOp::getMap)
.def("set_map_attr", &mlir::affine::AffineVectorLoadOp::setMapAttr, "attr"_a)
.def("set_map", &mlir::affine::AffineVectorLoadOp::setMap, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::VectorType resultType, mlir::AffineMap map, mlir::ValueRange operands){ return mlir::affine::AffineVectorLoadOp::build(odsBuilder, odsState, resultType, map, operands); }, "ods_builder"_a, "ods_state"_a, "result_type"_a, "map"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::VectorType resultType, mlir::Value memref, mlir::ValueRange indices){ return mlir::affine::AffineVectorLoadOp::build(odsBuilder, odsState, resultType, memref, indices); }, "ods_builder"_a, "ods_state"_a, "result_type"_a, "memref"_a, "indices"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::VectorType resultType, mlir::Value memref, mlir::AffineMap map, mlir::ValueRange mapOperands){ return mlir::affine::AffineVectorLoadOp::build(odsBuilder, odsState, resultType, memref, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "result_type"_a, "memref"_a, "map"_a, "map_operands"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value memref, mlir::ValueRange indices, mlir::AffineMapAttr map){ return mlir::affine::AffineVectorLoadOp::build(odsBuilder, odsState, result, memref, indices, map); }, "ods_builder"_a, "ods_state"_a, "result"_a, "memref"_a, "indices"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value memref, mlir::ValueRange indices, mlir::AffineMapAttr map){ return mlir::affine::AffineVectorLoadOp::build(odsBuilder, odsState, resultTypes, memref, indices, map); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "memref"_a, "indices"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Type result, mlir::Value memref, mlir::ValueRange indices, mlir::AffineMap map){ return mlir::affine::AffineVectorLoadOp::build(odsBuilder, odsState, result, memref, indices, map); }, "ods_builder"_a, "ods_state"_a, "result"_a, "memref"_a, "indices"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::Value memref, mlir::ValueRange indices, mlir::AffineMap map){ return mlir::affine::AffineVectorLoadOp::build(odsBuilder, odsState, resultTypes, memref, indices, map); }, "ods_builder"_a, "ods_state"_a, "result_types"_a, "memref"_a, "indices"_a, "map"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineVectorLoadOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def_static("parse", &mlir::affine::AffineVectorLoadOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineVectorLoadOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineVectorLoadOp::verifyInvariants)
.def("verify", &mlir::affine::AffineVectorLoadOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineVectorLoadOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("get_effects", &mlir::affine::AffineVectorLoadOp::getEffects, "effects"_a)
.def_prop_ro("mem_ref_operand_index", &mlir::affine::AffineVectorLoadOp::getMemRefOperandIndex)
.def("set_mem_ref", &mlir::affine::AffineVectorLoadOp::setMemRef, "value"_a)
.def_prop_ro("affine_map_attr", &mlir::affine::AffineVectorLoadOp::getAffineMapAttr)
.def_static("map_attr_str_name", &mlir::affine::AffineVectorLoadOp::getMapAttrStrName)
.def_prop_ro("vector_type", &mlir::affine::AffineVectorLoadOp::getVectorType)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineVectorLoadOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineVectorLoadOp>>(m, "TypeIDResolver[affine::AffineVectorLoadOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineVectorLoadOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineVectorStoreOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase>(m, "AffineVectorStoreOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::Properties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::affine::AffineVectorStoreOp>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("properties", &mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::getProperties)
.def_prop_ro("attributes", &mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::getAttributes)
.def_prop_ro("map_attr", &mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::getMapAttr)
.def_prop_ro("map", &mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::getMap)
;

auto mlir_affine_detail_AffineVectorStoreOpGenericAdaptorBase_Properties = nb::class_<mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::Properties>(mlir_affine_detail_AffineVectorStoreOpGenericAdaptorBase, "Properties")
.def_prop_ro("map", &mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::Properties::getMap)
.def("set_map", &mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::Properties::setMap, "prop_value"_a)
.def("__eq__", &mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::Properties::operator==, "rhs"_a)
.def("__ne__", &mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::Properties::operator!=, "rhs"_a)
;

auto mlir_affine_AffineVectorStoreOpAdaptor = nb::class_<mlir::affine::AffineVectorStoreOpAdaptor>(m, "AffineVectorStoreOpAdaptor")
.def(nb::init<mlir::affine::AffineVectorStoreOp>(), "op"_a)
.def("verify", &mlir::affine::AffineVectorStoreOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineVectorStoreOp = nb::class_<mlir::affine::AffineVectorStoreOp,  mlir::OpState>(m, "AffineVectorStoreOp")
.def_static("attribute_names", &mlir::affine::AffineVectorStoreOp::getAttributeNames)
.def_prop_ro("map_attr_name", [](mlir::affine::AffineVectorStoreOp& self){ return self.getMapAttrName(); })
.def_static("get_map_attr_name", [](mlir::OperationName name){ return mlir::affine::AffineVectorStoreOp::getMapAttrName(name); }, "name"_a)
.def_static("operation_name", &mlir::affine::AffineVectorStoreOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineVectorStoreOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineVectorStoreOp::getODSOperands, "index"_a)
.def_prop_ro("value", &mlir::affine::AffineVectorStoreOp::getValue)
.def_prop_ro("memref", &mlir::affine::AffineVectorStoreOp::getMemref)
.def_prop_ro("indices", &mlir::affine::AffineVectorStoreOp::getIndices)
.def_prop_ro("value_mutable", &mlir::affine::AffineVectorStoreOp::getValueMutable)
.def_prop_ro("memref_mutable", &mlir::affine::AffineVectorStoreOp::getMemrefMutable)
.def_prop_ro("indices_mutable", &mlir::affine::AffineVectorStoreOp::getIndicesMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineVectorStoreOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineVectorStoreOp::getODSResults, "index"_a)
.def_static("set_properties_from_attr", &mlir::affine::AffineVectorStoreOp::setPropertiesFromAttr, "prop"_a, "attr"_a, "emit_error"_a)
.def_static("get_properties_as_attr", &mlir::affine::AffineVectorStoreOp::getPropertiesAsAttr, "ctx"_a, "prop"_a)
.def_static("compute_properties_hash", &mlir::affine::AffineVectorStoreOp::computePropertiesHash, "prop"_a)
.def_static("get_inherent_attr", &mlir::affine::AffineVectorStoreOp::getInherentAttr, "ctx"_a, "prop"_a, "name"_a)
.def_static("set_inherent_attr", &mlir::affine::AffineVectorStoreOp::setInherentAttr, "prop"_a, "name"_a, "value"_a)
.def_static("populate_inherent_attrs", &mlir::affine::AffineVectorStoreOp::populateInherentAttrs, "ctx"_a, "prop"_a, "attrs"_a)
.def_static("verify_inherent_attrs", &mlir::affine::AffineVectorStoreOp::verifyInherentAttrs, "op_name"_a, "attrs"_a, "emit_error"_a)
.def_static("read_properties", &mlir::affine::AffineVectorStoreOp::readProperties, "reader"_a, "state"_a)
.def("write_properties", &mlir::affine::AffineVectorStoreOp::writeProperties, "writer"_a)
.def_prop_ro("map_attr", &mlir::affine::AffineVectorStoreOp::getMapAttr)
.def_prop_ro("map", &mlir::affine::AffineVectorStoreOp::getMap)
.def("set_map_attr", &mlir::affine::AffineVectorStoreOp::setMapAttr, "attr"_a)
.def("set_map", &mlir::affine::AffineVectorStoreOp::setMap, "attr_value"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value valueToStore, mlir::Value memref, mlir::ValueRange indices){ return mlir::affine::AffineVectorStoreOp::build(odsBuilder, odsState, valueToStore, memref, indices); }, "ods_builder"_a, "ods_state"_a, "value_to_store"_a, "memref"_a, "indices"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::Value valueToStore, mlir::Value memref, mlir::AffineMap map, mlir::ValueRange mapOperands){ return mlir::affine::AffineVectorStoreOp::build(odsBuilder, odsState, valueToStore, memref, map, mapOperands); }, "ods_builder"_a, "ods_state"_a, "value_to_store"_a, "memref"_a, "map"_a, "map_operands"_a)
.def_static("parse", &mlir::affine::AffineVectorStoreOp::parse, "parser"_a, "result"_a)
.def("verify_invariants_impl", &mlir::affine::AffineVectorStoreOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineVectorStoreOp::verifyInvariants)
.def("verify", &mlir::affine::AffineVectorStoreOp::verify)
.def_static("get_canonicalization_patterns", &mlir::affine::AffineVectorStoreOp::getCanonicalizationPatterns, "results"_a, "context"_a)
.def("get_effects", &mlir::affine::AffineVectorStoreOp::getEffects, "effects"_a)
.def_prop_ro("stored_val_operand_index", &mlir::affine::AffineVectorStoreOp::getStoredValOperandIndex)
.def_prop_ro("mem_ref_operand_index", &mlir::affine::AffineVectorStoreOp::getMemRefOperandIndex)
.def("set_mem_ref", &mlir::affine::AffineVectorStoreOp::setMemRef, "value"_a)
.def_prop_ro("affine_map_attr", &mlir::affine::AffineVectorStoreOp::getAffineMapAttr)
.def_static("map_attr_str_name", &mlir::affine::AffineVectorStoreOp::getMapAttrStrName)
.def_prop_ro("vector_type", &mlir::affine::AffineVectorStoreOp::getVectorType)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineVectorStoreOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineVectorStoreOp>>(m, "TypeIDResolver[affine::AffineVectorStoreOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineVectorStoreOp>::resolveTypeID)
;

auto mlir_affine_detail_AffineYieldOpGenericAdaptorBase = nb::class_<mlir::affine::detail::AffineYieldOpGenericAdaptorBase>(m, "AffineYieldOpGenericAdaptorBase")
.def(nb::init<mlir::DictionaryAttr, const mlir::EmptyProperties &, mlir::RegionRange>(), "attrs"_a, "properties"_a, "regions"_a)
.def(nb::init<mlir::Operation *>(), "op"_a)
.def("get_ods_operand_index_and_length", &mlir::affine::detail::AffineYieldOpGenericAdaptorBase::getODSOperandIndexAndLength, "index"_a, "ods_operands_size"_a)
.def_prop_ro("attributes", &mlir::affine::detail::AffineYieldOpGenericAdaptorBase::getAttributes)
;

auto mlir_affine_AffineYieldOpAdaptor = nb::class_<mlir::affine::AffineYieldOpAdaptor>(m, "AffineYieldOpAdaptor")
.def(nb::init<mlir::affine::AffineYieldOp>(), "op"_a)
.def("verify", &mlir::affine::AffineYieldOpAdaptor::verify, "loc"_a)
;

auto mlir_affine_AffineYieldOp = nb::class_<mlir::affine::AffineYieldOp,  mlir::OpState>(m, "AffineYieldOp")
.def_static("attribute_names", &mlir::affine::AffineYieldOp::getAttributeNames)
.def_static("operation_name", &mlir::affine::AffineYieldOp::getOperationName)
.def("get_ods_operand_index_and_length", &mlir::affine::AffineYieldOp::getODSOperandIndexAndLength, "index"_a)
.def("get_ods_operands", &mlir::affine::AffineYieldOp::getODSOperands, "index"_a)
.def_prop_ro("operands", &mlir::affine::AffineYieldOp::getOperands)
.def_prop_ro("operands_mutable", &mlir::affine::AffineYieldOp::getOperandsMutable)
.def("get_ods_result_index_and_length", &mlir::affine::AffineYieldOp::getODSResultIndexAndLength, "index"_a)
.def("get_ods_results", &mlir::affine::AffineYieldOp::getODSResults, "index"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState){ return mlir::affine::AffineYieldOp::build(odsBuilder, odsState); }, "ods_builder"_a, "ods_state"_a)
.def_static("build", [](mlir::OpBuilder & odsBuilder, mlir::OperationState & odsState, mlir::ValueRange operands){ return mlir::affine::AffineYieldOp::build(odsBuilder, odsState, operands); }, "ods_builder"_a, "ods_state"_a, "operands"_a)
.def_static("build", [](mlir::OpBuilder & _, mlir::OperationState & odsState, mlir::TypeRange resultTypes, mlir::ValueRange operands, llvm::ArrayRef<mlir::NamedAttribute> attributes){ return mlir::affine::AffineYieldOp::build(_, odsState, resultTypes, operands, attributes); }, "_"_a, "ods_state"_a, "result_types"_a, "operands"_a, "attributes"_a)
.def("verify_invariants_impl", &mlir::affine::AffineYieldOp::verifyInvariantsImpl)
.def("verify_invariants", &mlir::affine::AffineYieldOp::verifyInvariants)
.def("verify", &mlir::affine::AffineYieldOp::verify)
.def("get_mutable_successor_operands", &mlir::affine::AffineYieldOp::getMutableSuccessorOperands, "point"_a)
.def_static("parse", &mlir::affine::AffineYieldOp::parse, "parser"_a, "result"_a)
.def("get_effects", &mlir::affine::AffineYieldOp::getEffects, "effects"_a)
;

auto mlir_detail_TypeIDResolver___mlir_affine_AffineYieldOp__ = nb::class_<mlir::detail::TypeIDResolver< ::mlir::affine::AffineYieldOp>>(m, "TypeIDResolver[affine::AffineYieldOp]")
.def_static("resolve_type_id", &mlir::detail::TypeIDResolver< ::mlir::affine::AffineYieldOp>::resolveTypeID)
;

auto mlir_affine_AffineBound = nb::class_<mlir::affine::AffineBound>(m, "AffineBound")
.def_prop_ro("affine_for_op", &mlir::affine::AffineBound::getAffineForOp)
.def_prop_ro("map", &mlir::affine::AffineBound::getMap)
.def_prop_ro("num_operands", &mlir::affine::AffineBound::getNumOperands)
.def("get_operand", &mlir::affine::AffineBound::getOperand, "idx"_a)
.def("operand_begin", &mlir::affine::AffineBound::operandBegin)
.def("operand_end", &mlir::affine::AffineBound::operandEnd)
.def_prop_ro("operands", &mlir::affine::AffineBound::getOperands)
;

}
